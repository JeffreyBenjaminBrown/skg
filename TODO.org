* internalizing
  cargo nextest run
* TODO unordered, unsorted
** [[id:6d031428-eea3-4019-8122-80bd5fa6f9d4][rebuild buffer in Rust with the same structure \ skg]]
** rebuilding containerward view code
*** current setup
**** pub async fn containerward_org_view (
  driver         : &TypeDBDriver,
  config         : &SkgConfig,
  terminus       : &ID, // you could think of it as the origin, but everything else contains it, so I thought terminus was clearer
  terminus_level : usize,
) -> Result<String, Box<dyn Error>> {
***** pub async fn path_containerward_to_end_cycle_and_or_branches (
   db_name : &str,
   driver  : &TypeDBDriver,
   node    : &ID
 ) -> Result < ( Vec<ID>,    // the path, starting with the input
                 Option<ID>, // the first repeated node, if any
                 HashSet<ID> // branches, if any
***** async fn render_linear_portion_of_path (
   config: &SkgConfig,
   driver: &TypeDBDriver,
   path: &[ID],
   cycle_node: &Option<ID>,
   terminus_level: usize,
 ) -> Result<String, Box<dyn Error>> {
*** desired setup
    serial
**** in Emacs
***** User asks for containerward paths from a node.
***** Emacs adds '(request containerward-view)' to its metadata.
***** Emacs sends the entire buffer for re-rendering.
**** Rust saves and re-renders
***** Other nodes are re-rendered normally.
***** for the node with the containerward view request
****** call 'path_containerward_to_end_cycle_and_or_branches'
****** merge that information with the node's content
       Drop the head (terminus) of the containerward path.
******* for as long as the path is nonempty
        Look for the next among the node's children.
        If it's there, drop another head of the path,
        and recurse on what's left of the path and that new child.
        Otherwise, prepend a new treatment=ParentIgnores child
          (this could later be improved to use treatment=Content
          when the child is content)
        generating an OrgNode from that ID,
        and similarly recurse on the tail and that child.
******* if the path is empty
******** If there are branches,
         merge them all with the node's children.
         For any that are not among its children,
         create new treatment=ParentIgnores orgnodes,
         and prepend them.
******** If there are no branches, but a cycle node
         merge the cycle node with the node's children,
         or generate a new treatment=ParentIgnores one,
         and prepend it.
******** otherwise return without changes
** can't run skg-request-containerward-view
** read ahead in plans, estimate duration
   Do it not just for the durations,
   but to have a good sense of how complex each stage is.
** "indefinitive nodes skip the visited-checking logic entirely"
   when saving a buffer.
   This is not clearly a problem.
* ====== BELOW: SORTED, no execution order =======
* internalize
  Ask for a refactoring plan before embarking.
* features
* QA
** redundancies
*** mk_orgnode from save/buffer_to_orgnodes/uninterpreted.rs
    does something already done in mk_org_text/
*** Buffer_Cannot_Be_Saved and SaveError
** use the tests at not_using/pids_from_ids/tests.rs
** test the propagation of Buffer_Cannot_Be_Saved errors
   in commit 130318842f5ad0ad92279d14f85d8b950e6f844a,
   I started using
     find_buffer_errors_for_saving,
   which covers more cases than what I had been using,
     find_inconsistent_instructions
   But the tests only cover what
     find_inconsistent_instructions
   might return.
** integration test for containerward view
** not pressing
*** use s-exp parsing
**** in rust/serve/containerward_view.rs
     fn extract_containerward_view_params
**** in rust/serve/node_aliases.rs
     fn extract_node_aliases_params
**** in rust/serve/util.rs
***** definitely
      fn request_type_from_request (
      fn node_id_from_single_root_view_request (
      fn search_terms_from_request (
***** and maybe
      fn extract_quoted_value_from_sexp (
*** Avoid uses of `unwrap` in Rust.
*** find 'panic's, replace with Result.
*** Use anyhow or eyre crates for better error handling
**** Cargo.toml
  anyhow = "1.0"
**** usage
  use anyhow::Context;

  let driver = TypeDBDriver::new(...)
      .await
      .context("Failed to connect to TypeDB server")?;
*** once it's possible, make a good pids_from_ids
    see [[./not_using/pids_from_ids]]
* questions
** {Do, should} backward paths include node bodies?
* document
** that filenames must correspond to PIDs
** the dangers of repeated nodes to the user
   The original data model was that each node would have only one container. That proved infeasible, because the user can copy data at will. So skg accepts such data. But bear in mind that it is dangerous. The danger is this: If a node has branches, and is copied somewhere earlier in the same document, then that new copy will take precedence. Edits to it will be treated as *the* edits. If all you did was copy the node but not its branches, its branches will be lost when you save.
** find where to put this comment
 // Titles can include hyperlinks,
 // but can be searched for as if each hyperlink
 // was equal to its label, thanks to replace_each_link_with_its_label.
** change graph -> web
** drop [[../docs/progress.md][progress.md]]
** Didactically, concept maps > knowledge graph.
** [[../docs/data-model.md][The data model]] and [[../docs/sharing-model.md][The sharing model]] overlap
   as documents.
* solutions
** to extract Emacs properties into Rust
   use [[~/hodal/emacs/property-dump.el][property-dump]]
