* refactor: retain tree
  serial, control flow
** DONE buffer to orgnode forest
*** refuse and report all problems if any of these happen
**** a node appears twice without 'rep' or 'mightContainMore'.
**** an AliasColl node has a body, or a child with an ID
**** an Alias node has a body, or children
**** a node is marked 'delete' somewhere but not everywhere
**** a node has multiple AliasCol children
**** a node's contents are defined more than once
     exception: they can be appended to any number of times
*** assign IDs where needed
    see assign_ids_recursive
*** assign rel_to_parent=Alias where needed
** Forest<OrgNode2> -> Set<(SkgNode,NodeSaveAction)>
** collect SKgNodes with the same ID
** clobber the Set<(SkgNode,NodeSaveAction)>
   See 'clobber_none_fields_with_data_from_disk'.
   Extend to also add extra-ids.
   Do something similar for content,
     if SkgNodeSaveAction.might_contain_more == true.
** update_fs_and_dbs2
   uses the Set<(SkgNode,NodeSaveAction)>
*** TypeDB : update_nodes_and_relationships2
    First, for each toDelete node,
      delete every node using that ID, even if as an extra_id.
    Do the rest of the existing update_nodes_and_relationships
      only to the other nodes.
*** FS
**** write all non-delete nodes
     as normal, but filtering to only those nodes
**** delete all to-delete nodes
*** update_index_with_nodes
    Delete every entry for which the id is any toDelete id.
      not just the pid
    Add as normal.
** rebuild view
*** will build a Forest<OrgNode2> based on the original one
*** The result begins as a copy of the original one.
*** Process it DFS, keeping a full breadcrumb aath back to root.
*** Keep a running tally of which nodes have already been included in the result.
*** Any toDelete node is dropped, along with its content.
*** Every node is leeft in place except, maybe, nodes that are content of their parent.
    Leave even them in place if the parent is might_contain_more.
    Otherwise, remove them from the list,
    and add them back in based on looking them up elsewhere.
    Retain their metadata, so that 'leave these unchanged'
    can be executed, below.
*** recompute the following metadata values
**** cycle
     based on the breadcrumbs to root
**** rel_to_parent
     Verify Container relationships. If the relationship is no more,
     replace rel_to_parent=None.
**** repeat
*** leave these unchanged
**** might_contain_more
**** focused
**** folded
* Nodes with 'repeated' should also have 'mightContainMore'.
* Look at all my plans, and the code around saving, and ask what makes each difficult.
  Do this to know how to change the data structure,
  and likely the control flow.
* Navigate the tree in Rust as a tree.
* What {functions,types} bundle separble concerns?
** NodeWithEphem
* retain metadata when replacing node
  When a backview replaces text,
  it should retain the origin headline's
  relationship to its org-parent.
* link-sourceward view
** then eliminate further redundancy, if any
* generalize the Rust backpath rendering function
  Takes a lambda involving (probably)
    path_to_end_cycle_and_or_branches,
  and a starting level.
  The lambda can drop the first member of the path, or not.
* create new data without fetching preexisting data
  and add an integration test.
  Use a temp config, and delete it if the test passes.
* integration test for containerward view
* [[id:ba8fbc06-bb9c-4d69-bb1c-34cd1f80fdf4][multiple level-1 branches]]
* override the ordinary save command
* If there is a containerward "}" herald, the "ID exists" herald can be omitted.
* [[id:28d61c54-d474-4828-8ef9-e83b25c12ae8][heralds: more properties]]
  esp. rootness and multiple containment
* [[id:fb72f38e-bef6-4de9-a29b-00f0e46afbbb][deletion]]
* [[id:bc8fd4c3-0566-400c-96a8-0f4632e7fd1c][merging]]
* A node's ID should probably always be its primary one.
  In the medatata?
  As its name in the filesystem?
* retain focus, folding on save
** `org_from_node_recursive` should use its `focus` argument.
   This seems easy.
* not pressing
** refactoring
*** Parse metadata in Rust, not Emacs.
    see `skg-get-current-headline-metadata`
*** use s-exp parsing
**** in rust/serve/containerward_view.rs
     fn extract_containerward_view_params
**** in rust/serve/node_aliases.rs
     fn extract_node_aliases_params
**** in rust/serve/util.rs
***** definitely
      fn request_type_from_request (
      fn node_id_from_single_root_view_request (
      fn search_terms_from_request (
***** and maybe
      fn extract_quoted_value_from_sexp (
*** move empty_skgnode from tests into skgnode.rs
    and then use it for lots of tests
*** Use anyhow or eyre crates for better error handling
**** Cargo.toml
  anyhow = "1.0"
**** usage
  use anyhow::Context;

  let driver = TypeDBDriver::new(...)
      .await
      .context("Failed to connect to TypeDB server")?;
*** Avoid uses of `unwrap` in Rust.
** fancy features
*** show binary relationship label with optional intermediating node
    esp. nice if you can filter on those labels,
    or on an ontology they belong to that groups them
*** show when a link is bi-directional
*** list which links are in a node's recursive content
*** [[id:e6e855d9-f2e8-456e-87d7-e82379ead9f1][show co-targeters, co-ancestors]]
* idiot-proof the save mechanism
** Collect all duplicated nodes.
   The user might have edited the contents of each,
   even though they're not supposed to.
   If they have, keep the first one's title,
   add a warning about the title conflict if any
   to the warnings being accumulated,
   collect all of its contents from the different instances,
   and dedup that collection.
* document
** that filenames must correspond to PIDs
** the dangers of repeated nodes to the user
   The original data model was that each node would have only one container. That proved infeasible, because the user can copy data at will. So skg accepts such data. But bear in mind that it is dangerous. The danger is this: If a node has branches, and is copied somewhere earlier in the same document, then that new copy will take precedence. Edits to it will be treated as *the* edits. If all you did was copy the node but not its branches, its branches will be lost when you save.
** find where to put this comment
 // Titles can include hyperlinks,
 // but can be searched for as if each hyperlink
 // was equal to its label, thanks to replace_each_link_with_its_label.
** change graph -> web
** drop [[../docs/progress.md][progress.md]]
** Didactically, concept maps > knowledge graph.
** [[../docs/data-model.md][The data model]] and [[../docs/sharing-model.md][The sharing model]] overlap
   as documents.
* solutions
** to extract Emacs properties into Rust
   use [[~/hodal/emacs/property-dump.el][property-dump]]
