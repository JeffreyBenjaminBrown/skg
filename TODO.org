* replace
In a number of places there's a passage like this:

+        OrgnodeMetadata2 {
+          id : None,
+          relToOrgParent : RelToOrgParent2::SearchResult,
+          cycle : false,
+          focused : false,
+          folded : false,
+          mightContainMore : false,
+          repeat : false,
+          toDelete : false,
+        },

It would be less verbose if, in such places,
we just created an OrgnodeMetadata2 using default_metadata,
and then replaced the one or two fields different from the default.
* Propogate Buffer_Cannot_Be_Saved to user if it finds errors.
* I regret not having asked for a refactoring plan.
* What {functions,types} bundle separble concerns?
** NodeWithEphem
* retain metadata when replacing node
  When a backview replaces text,
  it should retain the origin headline's
  relationship to its org-parent.
* link-sourceward view
** then eliminate further redundancy, if any
* generalize the Rust backpath rendering function
  Takes a lambda involving (probably)
    path_to_end_cycle_and_or_branches,
  and a starting level.
  The lambda can drop the first member of the path, or not.
* create new data without fetching preexisting data
  and add an integration test.
  Use a temp config, and delete it if the test passes.
* integration test for containerward view
* [[id:ba8fbc06-bb9c-4d69-bb1c-34cd1f80fdf4][multiple level-1 branches]]
* override the ordinary save command
* If there is a containerward "}" herald, the "ID exists" herald can be omitted.
* [[id:28d61c54-d474-4828-8ef9-e83b25c12ae8][heralds: more properties]]
  esp. rootness and multiple containment
* [[id:fb72f38e-bef6-4de9-a29b-00f0e46afbbb][deletion]]
* [[id:bc8fd4c3-0566-400c-96a8-0f4632e7fd1c][merging]]
* A node's ID should probably always be its primary one.
  In the medatata?
  As its name in the filesystem?
* retain focus, folding on save
** `org_from_node_recursive` should use its `focus` argument.
   This seems easy.
* not pressing
** refactoring
*** Parse metadata in Rust, not Emacs.
    see `skg-get-current-headline-metadata`
*** use s-exp parsing
**** in rust/serve/containerward_view.rs
     fn extract_containerward_view_params
**** in rust/serve/node_aliases.rs
     fn extract_node_aliases_params
**** in rust/serve/util.rs
***** definitely
      fn request_type_from_request (
      fn node_id_from_single_root_view_request (
      fn search_terms_from_request (
***** and maybe
      fn extract_quoted_value_from_sexp (
*** move empty_skgnode from tests into skgnode.rs
    and then use it for lots of tests
*** Use anyhow or eyre crates for better error handling
**** Cargo.toml
  anyhow = "1.0"
**** usage
  use anyhow::Context;

  let driver = TypeDBDriver::new(...)
      .await
      .context("Failed to connect to TypeDB server")?;
*** Avoid uses of `unwrap` in Rust.
*** find 'panic's, replace with Result
*** once it's possible, make a good pids_from_ids
    see [[./not_using/pids_from_ids]]
** fancy features
*** show binary relationship label with optional intermediating node
    esp. nice if you can filter on those labels,
    or on an ontology they belong to that groups them
*** show when a link is bi-directional
*** list which links are in a node's recursive content
*** [[id:e6e855d9-f2e8-456e-87d7-e82379ead9f1][show co-targeters, co-ancestors]]
* idiot-proof the save mechanism
** Collect all duplicated nodes.
   The user might have edited the contents of each,
   even though they're not supposed to.
   If they have, keep the first one's title,
   add a warning about the title conflict if any
   to the warnings being accumulated,
   collect all of its contents from the different instances,
   and dedup that collection.
* document
** that filenames must correspond to PIDs
** the dangers of repeated nodes to the user
   The original data model was that each node would have only one container. That proved infeasible, because the user can copy data at will. So skg accepts such data. But bear in mind that it is dangerous. The danger is this: If a node has branches, and is copied somewhere earlier in the same document, then that new copy will take precedence. Edits to it will be treated as *the* edits. If all you did was copy the node but not its branches, its branches will be lost when you save.
** find where to put this comment
 // Titles can include hyperlinks,
 // but can be searched for as if each hyperlink
 // was equal to its label, thanks to replace_each_link_with_its_label.
** change graph -> web
** drop [[../docs/progress.md][progress.md]]
** Didactically, concept maps > knowledge graph.
** [[../docs/data-model.md][The data model]] and [[../docs/sharing-model.md][The sharing model]] overlap
   as documents.
* solutions
** to extract Emacs properties into Rust
   use [[~/hodal/emacs/property-dump.el][property-dump]]
