* ONGOING I just added a section 'Old style mod files are better' under coding-advice/.
  Please read that and adjust the module structure in server/ accordingly.
* how to review changes
** If what I asked for led it to make a function that addresses one case among the types badly, I'm probably screwing up.
   This happened when I asked AI to merge
   'merge' into the type containing 'save' and 'delete'.
* internalizing
** Don't refactor something without reading its comments.
   Even if it's as 'simple' as a type --
   non-obvious decisions often go into those brief definitions.
** Awkward or good ? Exactly some OrgNodes can have diffs.
   That makes some invalid state unrepresentable.
** how to prompt
*** when asking for a refactor
**** Name _v2 functions consistently.
**** Duplicate comments from _v1 functions
     (which keep their original names)
     into the _v2 functions.
*** when asking to move code
    Emphasize leaving whitespace, formatting unchanged.
** Don't reload without checking!
   If a buffer is empty when I don't think it should be,
   don't reload it. Check on disk if it is in fact empty.
   If not, try hitting 'undo' to restore it.
* ONGOING complete thoughts/buffer-update.org
* AWAITS NOT FULLY TESTED : git diff view
** refs
  see
    git-diff-view/big-plan.org
** TODO test
*** multiple repos
*** extending a definitive view from a removed node R
    one of whose children C is removed too,
    and such that C has a removed child and a non-removed child
** extract common logic from extendDefinitive* functions
   across from-git and from-worktree varieties.
** reading : comparing extending definitive from worktree and git
*** from worktree
**** // Mutate the root of the definitive view request:
**** from_disk_replace_title_body_and_skgnode(
**** // remove ViewRequest and mark definitive
**** // add to visited
**** extendDefinitiveSubtreeFromLeaf (
**** // maybe add a HiddenInSubscribeeCol
*** from git
    see which child IDs exist
** review
   The only code I'm still uncertain about is
     server/git_ops/diff.rs
     server/to_org/expand/definitive.rs
     server/to_org/render/diff.rs
   reading:
     server/serve/handlers/single_root_view.rs
* why clobber deletes?
In
  server/from_text/orgnodes_to_instructions.rs
there is:

pub async fn orgnode_forest_to_nonmerge_save_instructions (
  ...
  { let clobbered_node : SkgNode =
      // TODO ? It is natural to clobber Saves, but Deletes?
      noneclobber_skgnode (
        config, driver, instr.node().clone() ). await ?;
* Why a second path to noneclobber?
/// Build and return a Save instruction supplemented with disk data.
/// Replaces None fields in the instruction with values from disk,
/// and validates that sources match.
async fn build_supplemented_save(
* a grammar for describing tree manip
** one to map each orgnode kind to skgnode changes
   Keep a set of skgnodes.
   Different orgnodes can affect the same skgnode.
** one for how to build each orgnode kind
   Functions rather than types seem sufficient here.
   I don't think they ever need to know about orgnode neighbors.
* Permit BufferRoot to have no children.
* Search results should not use TrueNode.
* Most scaffolds need no title. Leave that to Emacs.
  How to display it should be left to Emacs.
* Heralds to indicate otherwise-invisible relationships.
** the 3 sharing relations in either direction
** aliases
** extra ids
* understand it
** [[id:9e83b23b-ebcb-426a-a1aa-6ceeabaaef2f][Skg save data flow trace]]
** Do de-novo and save reuse enough code?
*** De-novo is similar to execute definitive view request
    But do they share all the logic they ought to?
*** maybe see this document
    thoughts/saving-builds-tree-a-different-way.org
* refactor it
** for subscribee cols
   would be the following rule:

   If there could be a subscribee col and isn't,
   the herald just says that.
   When fetched it is included,
   but if the user deletes it from the view,
   it stays deleted until they request it again.
** TODO a herald for the presence of aliases
   Otherwise the user won't know whether to ask for them.
** alias, subscription, overrides, links
   Bools for whether it has
*** subscription action of any kind
*** aliases
*** overrides action of any kind
*** any links in
** TODO complete_or_restore_each_node_in_branch
*** When is it needed?
**** An AliasCol under an indefinitive parent could need updating.
     completeAliasCol
**** in a TrueNode
***** 'cycle' can need updating
      detect_and_mark_cycle
***** make_indef_if_repeat_then_extend_defmap
***** an indefinitive node can need updating
      Not really.
*** it could be called update_view
*** that it adds a subscribee col feels wrong
*** TODO ?
    Unbundle those two ideas.
    I think the completion is unnecessary. All it does is add a subscribeecol if it can.
** AWAITS Are there more unnecessary mid-functions?
   as in midparent in a tree
*** DONE flatten add_missing_info_to_forest
*** DONE mark_repeats_and_extend_defmap
**** two call chains lead to it
***** de novo
 * main
 ** serve
 *** handle_emacs
 **** handle_single_root_view_request
 ***** single_root_view
 ****** multi_root_view
 ******* render_initial_forest_bfs
 ******** stub_forest_from_root_ids
 ********* build_node_branch_minus_content
 ********** complete_branch_minus_content
 *********** mark_repeats_and_extend_defmap
***** save
 * main
 ** serve
 *** handle_emacs
 **** handle_save_buffer_request
 ***** update_from_and_rerender_buffer
 ****** complete_or_restore_each_node_in_branch
 ******* DUP mark_repeats_and_extend_defmap
** Search for other places to use do_everywhere_in_tree_dfs.
** Write how each piece, if inelegant, at least fits into an elegant scheme.
** ? validate ancestry, not descendents
   This seems like it might prevent combinatorial explosion.
   For instance, "an alias should have an aliascol parent"
   is easier to say than "an aliascol's children can only be aliases".
* extend it
** Why not use Git as the save safety layer?
   really need these all before releasing
** {see, edit} {subscribes, overrides, hides} relationships
** safe save
   If invalid state is detected in the course of a save,
   rollback to the previous state.
** save subscribees
*** the subscribee tree format
  - truenode // suppose this is a subscriber
    - subscribeeCol
      - [truenodes] // anything here is a subscribee
        - [truenodes] // nodes here are content of the subscribee
        - hiddeninsubscribeecol
          - [truenodes] // nodes here are hidden by the subscriber
      - hiddenoutsideofsubscribeecol
        - [truenodes]
*** extant procedure
    Currently, subscribees are collected, nothing more.
*** editing a subscribee
    Suppose R is a subscriber.
**** validate
     A TrueNode can have at most one SubscribeeCol.
     SubscribeeCol can have at most one Hiddenoutsideofsubscribeecol. Its TrueNode children (subscribees) cannot have the ID of its parent (subscriber) -- it can't subscribe to itself.
     Nothing special to validate in a subscribee.
     A Hidden*Col can only have TrueNode children.
**** generate instructions
***** collect subscribees
      Already implemented. Whether they are definitive has no effect.
***** collect hidden
      Recurse into R's definitive subscribees.
      For any such subcsribee E,
      make a list C of IDs of its non-ignored content children.
      Subtract from C any ID not in E's content on disk.
      Everything E contains on disk that is absent from C
      should be hidden from R.
**** update view
     The subscribees themselves need no updating,
     nor do their content, but the hidden*Cols do.
     For each hidden*Col, determine what it should contain,
     see what it already contains, and insert anything missing.
     Anything it should not contain should be marked parentIgnores.
     The order in a Hiddeninsubscribeecol should correspond
     to the order of the content of the subscribee.
     The order in a Hiddenoutsideofsubscribeecol should correspond
     to the order of the content of the subscriber's 'hidden' field.
*** ruminating
**** Edits to a foreign node.
     Creates a lens.
     It begins as whatever the user tried to save,
     plus an overrides relationship to the foreign node,
     plus a subscribes-to relationship to the foreign node,
     plus hides relationships to the intersection
     of its content and the foreign node's.
**** Edits to a subscribee.
     These don't make sense.
**** Edits to a subscribee's content.
     If it's deletion or insertion of a node the suscribee contains,
     update the subscriber's hidden list.
     If it's anything else, create a lens,
     and use the lens when showing the subscribee's recursive content.
**** A subscribee E can have its own subscribees.
     Editing one of those is an edit to E, i.e. doesn't make sense.
     To lens onto one, copy it elsewhere and edit that.
** show subscribees
* u
** dogfood it
** sourceward view ? ugly
   Rather than being top-level children,
   maybe they should be under a 'these link to it' scaffold.
** Develop a cleanup routine?
*** for local changes
**** Add type signatures to everything touched.
**** Update comments for anything that was touched.
     Including the header comment for any file, if needed.
*** for the whole codebase
**** Add type signatures.
**** Update list of user-facing functions in elisp/*.el.
** extension strategy for subscriptions
*** dataflow incrementalism
**** the idea
     Start from a new kind of action to receive from the client.
     Move it one phase along update_from_and_rerender_buffer.
     Provide a test that it gets there.
     Keep doing that.
**** a benefit
     It reduces the amount of context one needs to stay conscious of at each step.
**** a potential cost
     Might reduce the probability of seeing a global simplification.
** All I need working in order to use it.
*** safe save
*** some views I think work
**** (forward) content
**** herald # of parents
**** backward content
**** backward links
**** TODO forward links
*** some shortcuts
**** copy ID
**** make link
** Read the Rust repeatedly.
   More natural ways will become visible.
* s, by urgency
** Any place I can separate concerns by re-traversing the tree, do it.
** clarify completion
*** different completion logic in save-rerender and in new-buffer
**** in new-buffer
  ****** multi_root_view
  ******* render_initial_forest_bfs
  ******** render_generation_and_recurse
  ********* add_children_and_collect_their_ids
  ********** build_node_branch_minus_content
  *********** complete_branch_minus_content
**** in save-buffer
  ***** update_from_and_rerender_buffer
  ****** completeAndRestoreForest
** clarify execute_view_requests
   complex due to integration
** ? use a (map ID SkgNode) rather than pairing the forest
   Do this instead of
     pair_orgnode_forest_with_skgnodes_from_saveinstructions
   Would require rewriting a lot of code to take an orgnode forest and an id-skgnode map instead of PairTrees.
   Seems morally better: Two SkgNodes in a PairTree for the same ID could theoretically diverge, and even if they don't, the duplication wastes space.
   But access patterns would probably get uglier.
** ? definitive OrgNode != definitive skgnode
*** One is that the orgnode stuff is intended as definitive.
*** SkgNode might need definitive modifiers for each field.
** top-down breadth-first call graph analysis
*** to regenerate call graph .org files
    cargo run -p call-graph update_from_and_rerender_buffer
** DONE files that changed a lot since main
server/from_text/buffer_to_orgnodes/validate_tree.rs
  annoying, minor
server/types/orgnode.rs
server/serve/parse_metadata_sexp.rs
server/org_to_text.rs
** these seem redundant
clobberIndefinitiveOrgnode
indefinitize_content_subtree
makeIndefinitiveAndClobber
** DONE restructure types, divide Interp
*** DONE [[id:c4ac24d8-7a6b-4c09-9bec-64ee051d2703][Skg OrgNode type hierarchy]]
    NewOrgNode now separates TrueNode (Content, Subscribee, ParentIgnores)
    from Scaffold (BufferRoot, AliasCol, Alias, SubscribeeCol, etc.).
    Parsing pipeline produces Tree<NewOrgNode> directly.
*** ? two kinds of TrueNode
    one that might not have an ID, one that must
*** AWAITS refactor : Is the term 'Interp' gone?
    If so, rename kind -> interp.
*** NOTE: Body validation on Scaffolds
    Body_of_AliasCol and Body_of_Alias errors are no longer detectable
    post-parsing because Scaffold nodes don't store body data.
    These validations should happen during parsing if needed.
** AWAITS Completion is complex.
*** break up completeAndReorder_childrenOf_definitiveOrgnode
    it's super-long
*** Why do complete_branch_minus_content and completeAndReorder_childrenOf_definitiveOrgnode both call maybe_add_subscribeeCol_branch?
*** After 'view_requests_at_node', is there any reason to keep the view requests in the node?
    The function pushes the node's requests onto 'view_requests_out'.
    If they should be deleted from the node thereafter,
    the function should be renamed something like 'transfer_requests'.
*** On what Interps can 'completeAndReorder_childrenOf_definitiveOrgnode' be validly called?
    The comment says only nodes with Interp = Content.
    If that's right (I think so) the name should reflect it.
*** making something indefinitive twice
**** as of this commit
     dce37c085b5457953fa076dd2500a05e8635c87b
**** this passage
     mark_repeats_and_extend_defmap_or_cycle (
       tree, node_id, visited ) ?;
     { if is_indefinitive ( tree, node_id ) ? {
         clobberIndefinitiveOrgnode (
**** in this function
     complete_or_restore_each_node_in_branch
**** seems problematic
     because we're rewriting the node as indefinitive twice.
**** solution
     Don't call makeIndefinitiveAndClobber in
       mark_repeats_and_extend_defmap_or_cycle.
     Instead do it only in clobberIndefinitiveOrgnode.
     And in clobberIndefinitiveOrgnode, call makeIndefinitiveAndClobber,
     instead of essentially restating its definition.
*** maybe_add_hiddenInSubscribeeCol_branch should integrate
    if it finds the subscribee col,
    it can't assume that col is still accurate
*** ? ignorable
**** what if 'ensure_skgnode' is omitted?
***** omitted from complete_or_restore_each_node_in_branch
***** elaboration
      It seems like an absent skgnode where ensure_skgnode is called
      might be an unreachable state.
** AWAITS sharing
*** AWAITS subscription branches
**** PITFALL: Hiding is not ternary.
     SubscribeR node R Hides node H from *all* its subscriptions.
     When the nodes R hides are *displayed*,
       they can be grouped by their parents,
       and orphaned hidden nodes can be grouped separately,
     but in the graph they are not represented that way.
**** DONE Just like locally-owned nodes, make a Subscribee's Content into (the last and probably most of) its top-level children.
**** DONE Collect each subscribee's hidden in a HiddenCol midparent.
     The HiddenCol midparent is indefinitive.
     Its contents can be modified, and it can be deleted entirely,
     to no effect.
     Its contents respawn from disk on each save.
       (The user should perhaps be warned if that happens.)
**** DONE to populate Content and Hidden in a subscription branch, filter each subscribee's Contents into
****** Hidden = intersects with what the subscriber hides
****** Content = intersects not
**** DONE Collect hidden nodes that belong to no subscribee separately.
     in a midparent titled 'hidden outside of subscribees'.
     This one is also indefinite, respawning on each save.
**** Saving can change a subscription's contents in two ways.
***** via deletion
      Deleting a top-level node adds it to 'hidden'.
***** via insertion
****** Only something from 'hidden' can be inserted.
       This un-hides it.
****** Order does not matter.
       When saving,
       the subscribee branch'scontents are treated as a set,
       and intersected with the set of contents of the
         (foreign) subscribee.
**** When the user edits a subscribeeCol
     Its children determine what is subscribed to.
     The Contents of its children can be edited to change Hides relationships.
     The rest of the SubscribeeCol branch are respawned on save,
       and have no effect if edited before saving.
*** herald whether something has suubscriptions
*** extend saving for sharing relations
**** In saveinstructions_from_tree, recurse into subscribees
***** change this passage in saveinstructions_from_tree
      if matches!(interp, Interp::AliasCol                     |
                          Interp::Alias                        |
                          Interp::SubscribeeCol                | // TODO: Recurse into these
                          Interp::Subscribee                   | // TODO: Recurse into these
                          Interp::HiddenOutsideOfSubscribeeCol |
                          Interp::HiddenInSubscribeeCol        |
                          Interp::HiddenFromSubscribees ) {
        return Ok(()); } // Skip - these don't generate SaveInstructions
***** how to treat Subscribees
   If indefinitive, visit descendents but otherwise ignore.
   If definitive, treat its content list as a set,
     and hide in the subscriber anything not included.
***** how to treat foreign content
   Compare content to what's on disk.
   If there's a discrepancy, override and subscribe.
*** extend complete_or_restore_each_node_in_branch
    to complete a SubscribeeCol, and within one
    to handle Subscribees
** What does the SkgNode in a PairTree represent?
   If it's written by ensure_skgnode, it's from disk.
   But sometimes it's generated from the org tree.
   If this varies it should be encoded in the type --
   maybe with a boolean 'complete' flag,
   or a product of bools 'completionState'
   with, maybe, fields like
     id_present
     can_be_saved_this_way
     was_completed
** ONGOING simple refactors
*** reorg
**** DONE request 1
  Let's:
  - move everything in server/bin/ to tools/.
  - merge the three modules under save:: into save.rs
     and delete them.
  - rename compute_viewdata.rs to simply viewdata.rs
  - move cleanup_and_shutdown to the end of server/serve.rs,
     and delete the resulting empty module.
  - move init.rs into dbs/.
  - rename filesystem::misc to filesystem::not_nodes.
  - move  [[file:../../rust/dbs/typedb/util.rs::37][fn pid_and_source_from_id]] to server/dbs/typedb/search.rs.
  - rename to_dirty_instructions.rs to to_naive_instructions,
    and similarly for the two saveinstructions_from_* functions --
    call them naive_saveinstructions_from_*.
**** TODO RESUME around merge/ in tools/introspect/code-map/code-map.org
     reading downward
*** look for helpers to simplify egotree boilerplate
*** add an error possibility to 'mark_repeats_and_extend_defmap_or_cycle'
   if is_indefinitive {
     makeIndefinitiveAndClobber ( tree, node_id ) ?;
   } else { // here, it might already be in visited, which would be bad
     visited . insert ( pid, node_id ); }
*** add 'fn tree_nodepair_has_interp_subscribee'
    and call it everywhere a passage like this appears
  ```
    let is_subscribee : bool = {
      let node_ref : NodeRef < NodePair > =
        tree . get ( node_id ) . ok_or (
          "maybe_add_hiddenInSubscribeeCol_branch: node not found" ) ?;
      node_ref . value () . 1 . metadata . code . interp
        == Interp::Subscribee };
  ```
** likely helpful to generalize
*** remove_duplicates_and_false_aliases_handling_focus
    could be generalized to something that takes lambdas
    indicating whether something deserves removal
** ONGOING build, use the tree library
*** refs
    That library is currently at types/trees.
    Which seems okay.
    I had intended types to only be Skg types,
    but that doesn't seem important.
*** make something for is_ancestor_id to call
    Should find the first ancestor to which a lambda holds,
    and returns its ego_tree::NodeId.
*** replace get_pid_in_pairtree with the generic read_in_tree function
*** these should be generic
    nodes_after_in_generation
    collect_child_treeids
** aliases_to_org should rebuild the whole buffer
   like request containerward view
** real but minor
*** replace nstruction -> nstruc
** later
*** midparent in text : options
**** some examples
***** music */ THE MIDPARENT */ "the edge where ideas deserve ..."
****** its rendering into org-roam
       #+title: music
       * / & [[id:0a6dcf44-6c2c-432a-90a7-babfbb3e0b7d][justice]] & [[id:1e0eb0bc-1d40-4a78-9c81-dbcef73d005e][distance]] /
       ** the edge where ideas deserve not formal encoding yet in music
          :PROPERTIES:
          :ID:       eec10382-0ce9-4326-a1c7-f2ff477f19f0
          :END:
****** to read the midparent
       justice and distance are both routes from music to "the edge ..."
****** later
       could consider letting a similar midparent encode the unordered set (music, justice, distance)
***** a general one I like
****** a messed-up attempt at explicit syntax
******* [[..][/*predecessoor generation number]/name of relationship/
****** "/", "..", and ("ni" where the "i" is a running variable)
       It owuld look like a mix of slash-separated "ni"s and ".."s,
       such that in any sequence n1/n2   , n1 > n2
       and       in any sequence n1/../n2, n1 > n2
       i is usually greater than 0, so signifies predecessors;
       negative i signify descendents.
       If it starts with a / the entire predecessor chain is specified.
         "ni" is the alternative way to start.
         There is no reason to start or end with "..".
       If it ends with a / the entire descendent chain is specified.
         Not sure this is needed.
*** Can I download my git repo and read it ony phone with goto definition, find uses, etc?
*** 'content' count is wrong in Subsribees if any are hidden
*** add 'numSubscribees' near 'numLinksIn'
*** Is it natural that skg-request-save-buffer issues so many distinct calls to process-send-string?
* internalize
** ask AI to research and present options before implementing
*** Clear its context before doing that.
*** Includes even asking for refactoring plan.
*** why : helps me
*** why : helps the AI
    Loads up its context with good stuff,
    for when it finally implements the chosen path.
** cargo nextest run
** cargo test --doc
   runs 'doctests', which ensure code in documentation works.
** claude --dangerously-skip-permissions
   Less ergonomically, can say:
   "Don't do anything you don't have permission to do.
   I'm going to be away so I can't grant it."
* QA
** add tests
*** collect_generation_ids
    test the new effective root logic
** This seems like it could have been more efficient.
   server/to_org/definitive_branch.rs
   sharing more code with
   server/to_org/initial_view_bfs.rs
** Appending from indef nodes moght be a misfeature.
** completeContents seems too long
** RelToParent could be generalized as RelToAncestor.
   It would need both a relation and a number of levels.
   (RelToParent would translate to 1 level; to grandparent, 2; etc.)
** nah
*** 'merge' should be encodeable in NodeSaveAction
    Then I wouldn't need to parse the action twice,
    in two different ways.
** test validate_merge_requests
** in elisp/skg-sexpr/skg-lens.el, rather than concatenate with ":"
   (that's done by skg--tokens->string)

   Instead of returning a :-separated string,
   return a list of lists of propertized strings,
   which the calling function can decide how to concatenate.
** Indefinitive nodes skip the visited-checking logic
   when saving a buffer.
   This is not clearly a problem.
** Maybe indefinitive nodes and repeated nodes should be merged.
** these integration tests could be merged
focus-and-folded-markers
fold-preservation
** redundancies
*** linecol_to_orgnode from save/buffer_to_orgnodes/uninterpreted.rs
    does something already done in mk_org_text/
*** Buffer_Cannot_Be_Saved and SaveError
** use the tests at not_using/pids_from_ids/tests.rs
** test the propagation of Buffer_Cannot_Be_Saved errors
   in commit 130318842f5ad0ad92279d14f85d8b950e6f844a,
   I started using
     find_buffer_errors_for_saving,
   which covers more cases than what I had been using,
     find_inconsistent_instructions
   But the tests only cover what
     find_inconsistent_instructions
   might return.
** integration test for containerward view
** not pressing
*** use s-exp parsing
**** in server/serve/containerward_view.rs
     fn extract_containerward_view_params
**** in server/serve/node_aliases.rs
     fn extract_node_aliases_params
**** in server/serve/util.rs
***** definitely
      fn request_type_from_request (
      fn node_id_from_single_root_view_request (
      fn search_terms_from_request (
***** and maybe
      fn extract_quoted_value_from_sexp (
*** Avoid uses of `unwrap` in Rust.
*** find 'panic's, replace with Result.
*** Use anyhow or eyre crates for better error handling
**** Cargo.toml
  anyhow = "1.0"
**** usage
  use anyhow::Context;

  let driver = TypeDBDriver::new(...)
      .await
      .context("Failed to connect to TypeDB server")?;
*** once it's possible, make a good pids_from_ids
    see [[./not_using/pids_from_ids]]
** dedup some code
*** is_ancestor duplicates something done a different way elsewhere
* document
** that filenames must correspond to PIDs
** the dangers of repeated nodes to the user
   The original data model was that each node would have only one container. That proved infeasible, because the user can copy data at will. So skg accepts such data. But bear in mind that it is dangerous. The danger is this: If a node has branches, and is copied somewhere earlier in the same document, then that new copy will take precedence. Edits to it will be treated as *the* edits. If all you did was copy the node but not its branches, its branches will be lost when you save.
** find where to put this comment
 // Titles can include textlinks,
 // but can be searched for as if each textlink
 // was equal to its label, thanks to replace_each_link_with_its_label.
** change graph -> web
** drop [[../docs/progress.md][progress.md]]
** Didactically, concept maps > knowledge graph.
** [[../docs/data-model.md][The data model]] and [[../docs/sharing-model.md][The sharing model]] overlap
   as documents.
** "point" seems a better name than "node"
   But it conflicts with the Emacs 'point'.
* solutions
** search for type-oid
*** solution
    regex :
      (struct|enum|type)\s+.*TYPE_NAME
      (struct|enum|type|trait|union)\s+.*TYPE_NAME
    \s+ handles whitespace.
    To avoid matching superstrings, follow type name with \b
      \b is a word boundary to avoid matching SourceDiffFoo.
*** problem statement
    How would I search for the regex 'struct or enum or type followed by the name of it'? To find a typedef where I know the thing's name but not whether it's a sum type, product type or alias.
** reduce 4-space indentation to 2-space indentation
   sed -i 's/^\( *\)\1/\1/' THE_FILE
** to extract Emacs properties into Rust
   use [[~/hodal/emacs/property-dump.el][property-dump]]
** If I need to graft a forest's trees onto a false root,
   rctree can
   egotree can't
* save for posterity?
** planning docs for multi-source branch
   were deleted in this commit:
   2dfa2c764202138bb75cc247ffdeedddad8347d0
* dubious
** fold body into false headline
   there in Emacs but (at worst ignored) when Rust rebuilds
* if anyone else is reading this
** Most plans are not here but online.
   e.g. here:
   github.com/JeffreyBenjaminBrown/public_notes_with_github-navigable_links/blob/main/shareable_knowledge_gardens.org
   This document is mostly things I considered highest-priority.
