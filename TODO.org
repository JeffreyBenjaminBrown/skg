* architecture to change
** chnage OrgnodeMetadata
OrgnodeMetadata, // id, viewdata, code
  OrgnodeViewData, // focused, folded, repeated, cycle, relationships
    OrgnodeRelationships, // 2 bools, 3 ints
  OrgnodeCode, // relToParent, indef, editRequest (singular, optional), viewRequests (plural, set)
    RelToParent, // content | for aliases | ignored
    EditRequest, // merge | delete
    ViewRequest, // containerward | sourceward
** TypeDB is probably better for finding constraint violations.
*** Some states are invalid or redundant.
**** IDs should be unique.
**** Redundant state is possible.
***** A node can 'hide from subscriptions' something it contains.
      'contains' should imply 'hides from subscriptions'.
      (That is, the server should not display
      in one of a node's subscriptions
      something already shown in the node's content.)
** Code should render before viewdata
   and among code, first should be relToParent.
** dividing code
   Some is about save interpretation.
     Here, 'indef' should only be found where relToParent=content
   Some requests special edits: Delete, merge.
   Some requests views.
** 'indef' only makes sense if reltoparent = content
** merge and delete should be among an enum, 'graphActions'
   serial
*** make an invalid state impossible
    An orgnode has only one field for it, not a set,
    so they can't conflict with each other.
*** nodeRequests -> nodeViewRequests
** RelToParent seems better as RelToAncestor
   with two fields:
** rename Hyperlink -> TextLink
** merge the two Save errors
** rename indefinitive -> definesNotTextNorContents
** 'merge' should be encodeable in 'Nodesaveaction'
   Then I wouldn't need to parse the action twice,
   in two different ways.
** ViewData combines what to display with how to display.
   folded and focused are instructions to emacs,
   the rest, glyphs
** OrgnodeCode is unreasonable.
   Deletion is represented as a bool,
   but merge as an enum among view requests.
** If repeated, don't display indefinitive too.
** 'repeated' is view data, not code.
** 'indefinitive' should go wherever 'repeated' does.
   But not the reverse.
* TypeDB should report constraint violations.
  Yet succeed.
** good constraints
*** Each extra_id should be in at most one has_extra_id relationship.
*** Each id value should belong to only one entity.
    where entity = node | extra_id
* mk_skgnode is wrong
  It sets a lot of SkgNode list fields to None.
* most plans are online
  e.g. here:
  github.com/JeffreyBenjaminBrown/public_notes_with_github-navigable_links/blob/main/shareable_knowledge_gardens.org
* internalize
** ask AI to research and present options before implementing
*** Clear its context before doing that.
*** Includes even asking for refactoring plan.
*** why : helps me
*** why : helps the AI
    Loads up its context with good stuff,
    for when it finally implements the chosen path.
** cargo nextest run
** claude --dangerously-skip-permissions
   Less ergonomically, can say:
   "Don't do anything you don't have permission to do.
   I'm going to be away so I can't grant it."
* ? populate ./TODO/
  and then order links to them here like this:
  [[./TODO/sharing-and-privacy.org][sharing and privacy]]
* QA
** test validate_merge_requests
** in elisp/skg-sexpr/skg-lens.el, rather than concatenate with ":"
   (that's done by skg--tokens->string)

   Instead of returning a :-separated string,
   return a list of lists of propertized strings,
   which the calling function can decide how to concatenate.
** Indefinitive nodes skip the visited-checking logic
   when saving a buffer.
   This is not clearly a problem.
** Maybe indefinitive nodes and repeated nodes should be merged.
** these integration tests could be merged
focus-and-folded-markers
fold-preservation
** redundancies
*** mk_orgnode from save/buffer_to_orgnodes/uninterpreted.rs
    does something already done in mk_org_text/
*** Buffer_Cannot_Be_Saved and SaveError
** use the tests at not_using/pids_from_ids/tests.rs
** test the propagation of Buffer_Cannot_Be_Saved errors
   in commit 130318842f5ad0ad92279d14f85d8b950e6f844a,
   I started using
     find_buffer_errors_for_saving,
   which covers more cases than what I had been using,
     find_inconsistent_instructions
   But the tests only cover what
     find_inconsistent_instructions
   might return.
** integration test for containerward view
** not pressing
*** use s-exp parsing
**** in rust/serve/containerward_view.rs
     fn extract_containerward_view_params
**** in rust/serve/node_aliases.rs
     fn extract_node_aliases_params
**** in rust/serve/util.rs
***** definitely
      fn request_type_from_request (
      fn node_id_from_single_root_view_request (
      fn search_terms_from_request (
***** and maybe
      fn extract_quoted_value_from_sexp (
*** Avoid uses of `unwrap` in Rust.
*** find 'panic's, replace with Result.
*** Use anyhow or eyre crates for better error handling
**** Cargo.toml
  anyhow = "1.0"
**** usage
  use anyhow::Context;

  let driver = TypeDBDriver::new(...)
      .await
      .context("Failed to connect to TypeDB server")?;
*** once it's possible, make a good pids_from_ids
    see [[./not_using/pids_from_ids]]
* document
** that filenames must correspond to PIDs
** the dangers of repeated nodes to the user
   The original data model was that each node would have only one container. That proved infeasible, because the user can copy data at will. So skg accepts such data. But bear in mind that it is dangerous. The danger is this: If a node has branches, and is copied somewhere earlier in the same document, then that new copy will take precedence. Edits to it will be treated as *the* edits. If all you did was copy the node but not its branches, its branches will be lost when you save.
** find where to put this comment
 // Titles can include hyperlinks,
 // but can be searched for as if each hyperlink
 // was equal to its label, thanks to replace_each_link_with_its_label.
** change graph -> web
** drop [[../docs/progress.md][progress.md]]
** Didactically, concept maps > knowledge graph.
** [[../docs/data-model.md][The data model]] and [[../docs/sharing-model.md][The sharing model]] overlap
   as documents.
* solutions
** to extract Emacs properties into Rust
   use [[~/hodal/emacs/property-dump.el][property-dump]]
