* maybe_add_hidden_in_subscribee_col should integrate
  if it finds the subscribee col,
  it can't assume that col is still accurate
* 'content' count is wrong in Subsribees if any are hidden
* Don't delete those *Col branches.
  The user probably does not want them to disappear.
* fn tree_nodepair_has_interp_subscribee
  and call it everywhere a passage like this appears
```
    let is_subscribee : bool = {
    let node_ref : NodeRef < NodePair > =
      tree . get ( node_id ) . ok_or (
        "maybe_add_hidden_in_subscribee_col: node not found" ) ?;
    node_ref . value () . 1 . metadata . code . interp
      == Interp::Subscribee };
```
* extend completeAndRestoreNode_collectingViewRequests
  to complete a SubscribeeCol, and within one
* subscription branches
** PITFALL: Hiding is not ternary.
   SubscribeR node R Hides node H from *all* its subscriptions.
   When the nodes R hides are *displayed*,
     they can be grouped by their parents,
     and orphaned hidden nodes can be grouped separately,
   but in the graph they are not represented that way.
** Just like locally-owned nodes, make Content top-level children.
** Collect each subscribee's hidden in a HiddenCol midparent.
   The HiddenCol midparent is indefinitive.
   Its contents can be modified, and it can be deleted entirely,
   to no effect.
   Its contents respawn from disk on each save.
     (The user should perhaps be warned if that happens.)
** to populate Content and Hidden in a subscription branch, filter each subscribee's Contents into
**** Hidden = intersects with what the subscriber hides
**** Content = intersects not
** Collect hidden nodes that belong to no subscribee separately.
   in a midparent titled 'hidden outside of subscribees'.
   This one is also indefinite, respawning on each save.
** Saving can change a subscription's contents in two ways.
*** via deletion
    Deleting a top-level node adds it to 'hidden'.
*** via insertion
**** Only something from 'hidden' can be inserted.
     This un-hides it.
**** Order does not matter.
     When saving,
     the subscribee branch'scontents are treated as a set,
     and intersected with the set of contents of the
       (foreign) subscribee.
** When the user edits a subscribeeCol
   Its children determine what is subscribed to.
   The Contents of its children can be edited to change Hides relationships.
   The rest of the SubscribeeCol branch are respawned on save,
     and have no effect if edited before saving.
* for lossless smsn-encoding
** title, body and contents translate directly
** each alias is a child with text "(skg-as-smsn : alias) the-alias"
** sharing relationships are midparented
*** subscribes-to relationships are mediated by a '(skg-as-smsn : subscribes-to)' node
*** hides relationships are mediated by a '(skg-as-smsn : hides)' node
*** overrides relationships are mediated by a '(skg-as-smsn : overrides-to)' node
** ? omit extra_ids
   SmSn can't follow those links anyway.
* add 'numSubscribees' near 'numLinksIn'
* Is it natural that skg-request-save-buffer issues so many distinct calls to process-send-string?
* [[id:7dd8d9fd-8e7f-4719-a547-554eb182beb1][rescue smsn into skg]]
* aliases_to_org should rebuild the whole buffer
  like request containerward view
* most plans are online
  e.g. here:
  github.com/JeffreyBenjaminBrown/public_notes_with_github-navigable_links/blob/main/shareable_knowledge_gardens.org
* internalize
** ask AI to research and present options before implementing
*** Clear its context before doing that.
*** Includes even asking for refactoring plan.
*** why : helps me
*** why : helps the AI
    Loads up its context with good stuff,
    for when it finally implements the chosen path.
** cargo nextest run
** cargo test --doc
   runs 'doctests', which ensure code in documentation works.
** claude --dangerously-skip-permissions
   Less ergonomically, can say:
   "Don't do anything you don't have permission to do.
   I'm going to be away so I can't grant it."
* QA
** add tests
*** collect_generation_ids
    test the new effective root logic
** This seems like it could have been more efficient.
   rust/to_org/definitive_branch.rs
   sharing more code with
   rust/to_org/initial_view_bfs.rs
** Appending from indef nodes moght be a misfeature.
** completeContents seems too long
** RelToParent could be generalized as RelToAncestor.
   It would need both a relation and a number of levels.
   (RelToParent would translate to 1 level; to grandparent, 2; etc.)
** nah
*** 'merge' should be encodeable in NodeSaveAction
    Then I wouldn't need to parse the action twice,
    in two different ways.
** test validate_merge_requests
** in elisp/skg-sexpr/skg-lens.el, rather than concatenate with ":"
   (that's done by skg--tokens->string)

   Instead of returning a :-separated string,
   return a list of lists of propertized strings,
   which the calling function can decide how to concatenate.
** Indefinitive nodes skip the visited-checking logic
   when saving a buffer.
   This is not clearly a problem.
** Maybe indefinitive nodes and repeated nodes should be merged.
** these integration tests could be merged
focus-and-folded-markers
fold-preservation
** redundancies
*** linecol_to_orgnode from save/buffer_to_orgnodes/uninterpreted.rs
    does something already done in mk_org_text/
*** Buffer_Cannot_Be_Saved and SaveError
** use the tests at not_using/pids_from_ids/tests.rs
** test the propagation of Buffer_Cannot_Be_Saved errors
   in commit 130318842f5ad0ad92279d14f85d8b950e6f844a,
   I started using
     find_buffer_errors_for_saving,
   which covers more cases than what I had been using,
     find_inconsistent_instructions
   But the tests only cover what
     find_inconsistent_instructions
   might return.
** integration test for containerward view
** not pressing
*** use s-exp parsing
**** in rust/serve/containerward_view.rs
     fn extract_containerward_view_params
**** in rust/serve/node_aliases.rs
     fn extract_node_aliases_params
**** in rust/serve/util.rs
***** definitely
      fn request_type_from_request (
      fn node_id_from_single_root_view_request (
      fn search_terms_from_request (
***** and maybe
      fn extract_quoted_value_from_sexp (
*** Avoid uses of `unwrap` in Rust.
*** find 'panic's, replace with Result.
*** Use anyhow or eyre crates for better error handling
**** Cargo.toml
  anyhow = "1.0"
**** usage
  use anyhow::Context;

  let driver = TypeDBDriver::new(...)
      .await
      .context("Failed to connect to TypeDB server")?;
*** once it's possible, make a good pids_from_ids
    see [[./not_using/pids_from_ids]]
** dedup some code
*** is_ancestor duplicates something done a different way elsewhere
* document
** that filenames must correspond to PIDs
** the dangers of repeated nodes to the user
   The original data model was that each node would have only one container. That proved infeasible, because the user can copy data at will. So skg accepts such data. But bear in mind that it is dangerous. The danger is this: If a node has branches, and is copied somewhere earlier in the same document, then that new copy will take precedence. Edits to it will be treated as *the* edits. If all you did was copy the node but not its branches, its branches will be lost when you save.
** find where to put this comment
 // Titles can include textlinks,
 // but can be searched for as if each textlink
 // was equal to its label, thanks to replace_each_link_with_its_label.
** change graph -> web
** drop [[../docs/progress.md][progress.md]]
** Didactically, concept maps > knowledge graph.
** [[../docs/data-model.md][The data model]] and [[../docs/sharing-model.md][The sharing model]] overlap
   as documents.
** "point" seems a better name than "node"
   But it conflicts with the Emacs 'point'.
* solutions
** to extract Emacs properties into Rust
   use [[~/hodal/emacs/property-dump.el][property-dump]]
** If I need to graft a forest's trees onto a false root,
   rctree can
   egotree can't
* save for posterity?
** planning docs for multi-source branch
   were deleted in this commit:
   2dfa2c764202138bb75cc247ffdeedddad8347d0
* dubious
** fold body into false headline
   there in Emacs but (at worst ignored) when Rust rebuilds
