* rename reconcile_dup_instructions
  and the module it's in
* maybe we don't need the SaveIndefinitive constructor
  and can rename the other Save* to simply 'Save'
* dfs-bfs and request view expansion
** SOLVED (in theory)
   Here's how to unify the two things below:
   So far the bfs-dfs truncation view
   applies a limit to the entire forest.
   Permit the user to request recursive content views from anywhere.
   Once the forest is rendered,
   these content views are rendered just like the whole forest was,
   with a depth limit that only applies to that branch.

   The limit only needs to apply to the initial render;
   it does not need to be re-applied at each save
   (unless the save includes a new recursive content view request
   to un-truncate a node currently rendered truncated).
** dfs truncation-leaf renderings performed with count-limited bfs
*** functions for initial population of a view
**** fn mk_indefinitive_node
     Title and metadata (with indef=true).
     No body, no children.
**** fn mk_definitive_node
     Change 'indef' in metadata.
     Include body, children.
*** representation as a few simple functions
**** fn render : list of roots -> tree
 Populate the tree with all the roots in truncated form.
 Set 'count' = number of roots.
 Call 'show-children-of-generation' repeatedly on (Forest, Count)
   until Count exceeds the limit.
**** fn render-children-of-generation : [inputs] -> (Forest, Count)
***** inputs
****** the mutable output forest
****** the number of nodes rendered so far in it
****** a generation G : int
****** the node limit L : int
***** loop
****** Start at 'node' = first-in-gen.
       for each tree in the forest
****** If the limit of showable nodes has been reached
       then return the forest and the new rendered-node count
****** Otherwise
******* render the node's children in truncated form
******* add that number of children to the stored number rendered
******* go to the next node in this generation, or return
        If there is no next node in this generation,
        then return the forest and the new rendered-node count.
**** fn next-in-generation : Node -> Maybe Node
     Given a node N,
     gets the next member of that generation.
**** fn first-in-generation : Int -> Node
     Given N >= 1,
     gets the first member of that generation.
*** some terms
    A truncation-leaf is a leaf headline.
    Ideally it gives a sense of the shape of what it omits,
      e.g. [[id:d3d4945c-3e28-474b-9b9b-87592b1d4b69][of the containerward manifold]].
*** the whole idea
    Once a layer L of the tree is completely written in truncated form,
    if the bfs node limit has not been reached,
    the next layer L2
      (found using something like the
      [[id:1c84728d-cc81-4749-a538-5c71875b6345][next-same-level function for forests : node -> node]])
    is traversed, rendering truncated headlines of L3.
    As soon as the limit is hit, that set of siblings is completed,
    and the forest is returned.
*** ? Can it be represented via preorder-postorder?
** Request definitive view at a node
*** for repeats
*** for subscriptions
    which initially show just the title -- not even the content,
      let alone the recursive content
* truncation resembles folding
** 'folded': emacs org-mode folding
** 'truncated': whether a node's contents are among its children
   If a node is truncated, it should be indefinitive.
* showing an indefinitive node's body is fine
  The user can delete it if they want; no effect.
  They can also hide it in a 'to delete' node.
  Oh but whether the user wants the body
  should be preserved by the server when saving.
* undoing that mis-feature shouldn't be hard
  Don't let indefinite nodes contribute at all to saving,
  but recognize that their children might.
* [[id:7dd8d9fd-8e7f-4719-a547-554eb182beb1][rescue smsn into skg]]
* aliases_to_org should rebuild the whole buffer
  like request containerward view
* most plans are online
  e.g. here:
  github.com/JeffreyBenjaminBrown/public_notes_with_github-navigable_links/blob/main/shareable_knowledge_gardens.org
* internalize
** ask AI to research and present options before implementing
*** Clear its context before doing that.
*** Includes even asking for refactoring plan.
*** why : helps me
*** why : helps the AI
    Loads up its context with good stuff,
    for when it finally implements the chosen path.
** cargo nextest run
** cargo test --doc
   runs 'doctests', which ensure code in documentation works.
** claude --dangerously-skip-permissions
   Less ergonomically, can say:
   "Don't do anything you don't have permission to do.
   I'm going to be away so I can't grant it."
* QA
** Appending from indef nodes moght be a misfeature.
** completeContents seems too long
** RelToParent could be generalized as RelToAncestor.
   It would need both a relation and a number of levels.
   (RelToParent would translate to 1 level; to grandparent, 2; etc.)
** nah
*** 'merge' should be encodeable in NodeSaveAction
    Then I wouldn't need to parse the action twice,
    in two different ways.
** test validate_merge_requests
** in elisp/skg-sexpr/skg-lens.el, rather than concatenate with ":"
   (that's done by skg--tokens->string)

   Instead of returning a :-separated string,
   return a list of lists of propertized strings,
   which the calling function can decide how to concatenate.
** Indefinitive nodes skip the visited-checking logic
   when saving a buffer.
   This is not clearly a problem.
** Maybe indefinitive nodes and repeated nodes should be merged.
** these integration tests could be merged
focus-and-folded-markers
fold-preservation
** redundancies
*** mk_orgnode from save/buffer_to_orgnodes/uninterpreted.rs
    does something already done in mk_org_text/
*** Buffer_Cannot_Be_Saved and SaveError
** use the tests at not_using/pids_from_ids/tests.rs
** test the propagation of Buffer_Cannot_Be_Saved errors
   in commit 130318842f5ad0ad92279d14f85d8b950e6f844a,
   I started using
     find_buffer_errors_for_saving,
   which covers more cases than what I had been using,
     find_inconsistent_instructions
   But the tests only cover what
     find_inconsistent_instructions
   might return.
** integration test for containerward view
** not pressing
*** use s-exp parsing
**** in rust/serve/containerward_view.rs
     fn extract_containerward_view_params
**** in rust/serve/node_aliases.rs
     fn extract_node_aliases_params
**** in rust/serve/util.rs
***** definitely
      fn request_type_from_request (
      fn node_id_from_single_root_view_request (
      fn search_terms_from_request (
***** and maybe
      fn extract_quoted_value_from_sexp (
*** Avoid uses of `unwrap` in Rust.
*** find 'panic's, replace with Result.
*** Use anyhow or eyre crates for better error handling
**** Cargo.toml
  anyhow = "1.0"
**** usage
  use anyhow::Context;

  let driver = TypeDBDriver::new(...)
      .await
      .context("Failed to connect to TypeDB server")?;
*** once it's possible, make a good pids_from_ids
    see [[./not_using/pids_from_ids]]
* document
** that filenames must correspond to PIDs
** the dangers of repeated nodes to the user
   The original data model was that each node would have only one container. That proved infeasible, because the user can copy data at will. So skg accepts such data. But bear in mind that it is dangerous. The danger is this: If a node has branches, and is copied somewhere earlier in the same document, then that new copy will take precedence. Edits to it will be treated as *the* edits. If all you did was copy the node but not its branches, its branches will be lost when you save.
** find where to put this comment
 // Titles can include textlinks,
 // but can be searched for as if each textlink
 // was equal to its label, thanks to replace_each_link_with_its_label.
** change graph -> web
** drop [[../docs/progress.md][progress.md]]
** Didactically, concept maps > knowledge graph.
** [[../docs/data-model.md][The data model]] and [[../docs/sharing-model.md][The sharing model]] overlap
   as documents.
** "point" seems a better name than "node"
   But it conflicts with the Emacs 'point'.
* solutions
** to extract Emacs properties into Rust
   use [[~/hodal/emacs/property-dump.el][property-dump]]
** If I need to graft a forest's trees onto a false root,
   rctree can
   egotree can't
* save for posterity?
** planning docs for multi-source branch
   were deleted in this commit:
   2dfa2c764202138bb75cc247ffdeedddad8347d0
* dubious
** fold body into false headline
   there in Emacs but (at worst ignored) when Rust rebuilds
