* merge nodes
** see also
*** ask.org
*** merge-temp-docs/ (in branch merge-nodes)
** TODO
*** test validate_merge_requests
*** use them
**** use these
***** ONGOING validate_merge_requests
***** instructiontriples_from_the_merges_in_an_orgnode_forest
***** merge_nodes_in_graph
**** use them here
     in buffer_to_save_instructions
*** document in comments
**** three saveinstructions per merge
     a merge produces three SaveInstructions:
       create, update, delete
     rather than just updating two nodes.
**** justify these rules
***** Acquiree as replaced → DROP
***** Acquiree as hidden → DROP
**** when merge requests are processed
***** // Merge requests are handled during save, not rebuild/view
      this comment probably needs rewording
***** merge requests are ignored
      in 'complete_node_preorder',
      and thus in its (more meaningfully-named) caller
      'completeOrgnodeForest'
** AWAITS reading history
   reading upward in the git log as shown by magit
*** TODO last file completely read
    rust/rebuild.rs
    but that was a few commits ago
** changes since main
*** Add Merge(ID) constructor to NodeRequest
 pub enum NodeRequest {
   ContainerwardView,
   SourcewardView,
   Merge(ID),  // Request to merge another node into this one
 }
*** Add 'extra_ids_from_pid' in typedb::search
    +pub async fn extra_ids_from_pid(
    +  db_name: &str,
    +  driver: &TypeDBDriver,
    +  node_id: &ID,
    +) -> Result<Vec<ID>, Box<dyn Error>> {
*** the merge algorithm
** DONE
*** Don't detect text!
 You write that the string 'MERGED-' is used to classify nodes. That's dangerous. Instead, would it be feasible to define a struct 'Merge_3_SaveInstructions', with fields that specify which is the 'acquirer', which the 'acquiree', and which the 'preserver' (of the acquiree's text)?
**** Title Format - Changed acquiree_text_preserver title from "MERGED: " to "MERGED-" to avoid Tantivy query syntax conflicts with colons
*** The SkgNodes in the three SaveInstruction should have all the relevant information.
**** 1
 Great!

 Next: The information computed here:
 ```
     // Compute final relationship fields for acquirer
     let acquirer_final_contains : HashSet<ID> =
       updated_acquirer.contains.iter().cloned().collect();

     let mut acquirer_to_write : SkgNode = updated_acquirer.clone();

     // Combine hides_from_its_subscriptions (with filtering)
     let mut combined_hides : Vec<ID> = Vec::new();
     for list in [&updated_acquirer.hides_from_its_subscriptions,
                  &acquiree.hides_from_its_subscriptions] {
       if let Some(hides_list) = list {
         for hidden_id in hides_list {
           if !acquirer_final_contains.contains(hidden_id)
              && !combined_hides.contains(hidden_id) {
             combined_hides.push(hidden_id.clone());
           }
         }
       }
     }
     acquirer_to_write.hides_from_its_subscriptions = Some(combined_hides);

     // Combine subscribes_to
     acquirer_to_write.subscribes_to = Some(
       updated_acquirer.subscribes_to.clone().unwrap_or_default()
         .into_iter()
         .chain(acquiree.subscribes_to.clone().unwrap_or_default())
         .collect()
     );

     // Combine overrides_view_of
     acquirer_to_write.overrides_view_of = Some(
       updated_acquirer.overrides_view_of.clone().unwrap_or_default()
         .into_iter()
         .chain(acquiree.overrides_view_of.clone().unwrap_or_default())
         .collect()
     );
 ```
 should be calculated earlier, in 'saveinstructions_from_the_merge_in_a_node'.
**** 2
 Can you move the SaveInstruction-creating functions in rust/merge.rs to a new file, rust/merge/mergeInstructionTriple.rs? And move the code that defines the acquirer's fields to a standalone function?
*** be sure this is tested
 Great! Next, can you look through the tests and make sure the following two properties are being tested somewhere?

 - If A is merged into B and A was hyperlinked to C, now the first child of B is hyperlinked to C.
 - If A is merged into B and C was hyperlinked to A, now C is hyperlinked to B.
*** SkgNode serialization
 Next let's work on how SkgNodes are interpreted. Currently a SkgNode's optional list fields are not written to disk if they are None, but they *are* written if they are Some([]). I want them not written to disk either way. And when they are read from disk, if they are absent, they should be read as None values.

 This means writing and reading is not an isomorphism. That's fine -- a SkgNode might or might not have something to say about any of its optional lists. That's why there exists code (reconcile_dup_instructions and clobber_none_fields_with_data_from_disk) for joining what multiple SkgNodes have to say about a field.
*** move extra_ids_from_pid to rust/test-utils.rs
* u
** reconcile_dup_instructions_for_one_id
*** It must handle the other optional lists.
*** Is it called only after IDs are replaced with PIDs?
** make sure we can't merge more than 1 node into another per save
** mk_skgnode is wrong
   It sets a lot of SkgNode list fields to None.
** Does anything fail silently?
* most plans are online
  e.g. here:
  github.com/JeffreyBenjaminBrown/public_notes_with_github-navigable_links/blob/main/shareable_knowledge_gardens.org
* internalize
** ask AI to research and present options before implementing
*** Clear its context before doing that.
*** Includes even asking for refactoring plan.
*** why : helps me
*** why : helps the AI
    Loads up its context with good stuff,
    for when it finally implements the chosen path.
** cargo nextest run
** claude --dangerously-skip-permissions
   Less ergonomically, can say:
   "Don't do anything you don't have permission to do.
   I'm going to be away so I can't grant it."
* ? populate ./TODO/
  and then order links to them here like this:
  [[./TODO/sharing-and-privacy.org][sharing and privacy]]
* QA
** in elisp/skg-sexpr/skg-lens.el, rather than concatenate with ":"
   (that's done by skg--tokens->string)

   Instead of returning a :-separated string,
   return a list of lists of propertized strings,
   which the calling function can decide how to concatenate.
** Indefinitive nodes skip the visited-checking logic
   when saving a buffer.
   This is not clearly a problem.
** Maybe indefinitive nodes and repeated nodes should be merged.
** these integration tests could be merged
focus-and-folded-markers
fold-preservation
** redundancies
*** mk_orgnode from save/buffer_to_orgnodes/uninterpreted.rs
    does something already done in mk_org_text/
*** Buffer_Cannot_Be_Saved and SaveError
** use the tests at not_using/pids_from_ids/tests.rs
** test the propagation of Buffer_Cannot_Be_Saved errors
   in commit 130318842f5ad0ad92279d14f85d8b950e6f844a,
   I started using
     find_buffer_errors_for_saving,
   which covers more cases than what I had been using,
     find_inconsistent_instructions
   But the tests only cover what
     find_inconsistent_instructions
   might return.
** integration test for containerward view
** not pressing
*** use s-exp parsing
**** in rust/serve/containerward_view.rs
     fn extract_containerward_view_params
**** in rust/serve/node_aliases.rs
     fn extract_node_aliases_params
**** in rust/serve/util.rs
***** definitely
      fn request_type_from_request (
      fn node_id_from_single_root_view_request (
      fn search_terms_from_request (
***** and maybe
      fn extract_quoted_value_from_sexp (
*** Avoid uses of `unwrap` in Rust.
*** find 'panic's, replace with Result.
*** Use anyhow or eyre crates for better error handling
**** Cargo.toml
  anyhow = "1.0"
**** usage
  use anyhow::Context;

  let driver = TypeDBDriver::new(...)
      .await
      .context("Failed to connect to TypeDB server")?;
*** once it's possible, make a good pids_from_ids
    see [[./not_using/pids_from_ids]]
* document
** that filenames must correspond to PIDs
** the dangers of repeated nodes to the user
   The original data model was that each node would have only one container. That proved infeasible, because the user can copy data at will. So skg accepts such data. But bear in mind that it is dangerous. The danger is this: If a node has branches, and is copied somewhere earlier in the same document, then that new copy will take precedence. Edits to it will be treated as *the* edits. If all you did was copy the node but not its branches, its branches will be lost when you save.
** find where to put this comment
 // Titles can include hyperlinks,
 // but can be searched for as if each hyperlink
 // was equal to its label, thanks to replace_each_link_with_its_label.
** change graph -> web
** drop [[../docs/progress.md][progress.md]]
** Didactically, concept maps > knowledge graph.
** [[../docs/data-model.md][The data model]] and [[../docs/sharing-model.md][The sharing model]] overlap
   as documents.
* solutions
** to extract Emacs properties into Rust
   use [[~/hodal/emacs/property-dump.el][property-dump]]
