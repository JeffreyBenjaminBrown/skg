* internalize
  Ask for a refactoring plan before embarking.
* research
** What {functions, types} bundle separble concerns?
** look for TODO items
* features
** rebuild buffer with the same structure
*** retain metadata when replacing node
    When a backview replaces text,
    it should retain the origin headline's
    relationship to its org-parent.
*** retain focus, folding on save
**** `org_from_node_recursive` should use its `focus` argument.
     This seems easy.
** [[id:ba8fbc06-bb9c-4d69-bb1c-34cd1f80fdf4][multiple level-1 branches]]
** generalize the Rust backpath rendering function
   Takes a lambda involving (probably)
     path_to_end_cycle_and_or_branches,
   and a starting level.
   The lambda can drop the first member of the path, or not.
** link-sourceward view
*** then eliminate further redundancy, if any
** override the ordinary save command
** If there is a containerward "}" herald, the "ID exists" herald can be omitted.
** [[id:28d61c54-d474-4828-8ef9-e83b25c12ae8][heralds: more properties]]
   esp. rootness and multiple containment
** [[id:fb72f38e-bef6-4de9-a29b-00f0e46afbbb][deletion]]
** [[id:bc8fd4c3-0566-400c-96a8-0f4632e7fd1c][merging]]
** not pressing
*** show binary relationship label with optional intermediating node
    esp. nice if you can filter on those labels,
    or on an ontology they belong to that groups them
*** show when a link is bi-directional
*** list which links are in a node's recursive content
*** [[id:e6e855d9-f2e8-456e-87d7-e82379ead9f1][show co-targeters, co-ancestors]]
* QA
** test the propagation of Buffer_Cannot_Be_Saved errors
   in commit 130318842f5ad0ad92279d14f85d8b950e6f844a,
   I started using
     find_buffer_errors_for_saving,
   which covers more cases than what I had been using,
     find_inconsistent_instructions
   But the tests only cover what
     find_inconsistent_instructions
   might return.
** integration test for containerward view
** not pressing
*** use s-exp parsing
**** in rust/serve/containerward_view.rs
     fn extract_containerward_view_params
**** in rust/serve/node_aliases.rs
     fn extract_node_aliases_params
**** in rust/serve/util.rs
***** definitely
      fn request_type_from_request (
      fn node_id_from_single_root_view_request (
      fn search_terms_from_request (
***** and maybe
      fn extract_quoted_value_from_sexp (
*** Avoid uses of `unwrap` in Rust.
*** find 'panic's, replace with Result.
*** Use anyhow or eyre crates for better error handling
**** Cargo.toml
  anyhow = "1.0"
**** usage
  use anyhow::Context;

  let driver = TypeDBDriver::new(...)
      .await
      .context("Failed to connect to TypeDB server")?;
*** once it's possible, make a good pids_from_ids
    see [[./not_using/pids_from_ids]]
* document
** that filenames must correspond to PIDs
** the dangers of repeated nodes to the user
   The original data model was that each node would have only one container. That proved infeasible, because the user can copy data at will. So skg accepts such data. But bear in mind that it is dangerous. The danger is this: If a node has branches, and is copied somewhere earlier in the same document, then that new copy will take precedence. Edits to it will be treated as *the* edits. If all you did was copy the node but not its branches, its branches will be lost when you save.
** find where to put this comment
 // Titles can include hyperlinks,
 // but can be searched for as if each hyperlink
 // was equal to its label, thanks to replace_each_link_with_its_label.
** change graph -> web
** drop [[../docs/progress.md][progress.md]]
** Didactically, concept maps > knowledge graph.
** [[../docs/data-model.md][The data model]] and [[../docs/sharing-model.md][The sharing model]] overlap
   as documents.
* solutions
** to extract Emacs properties into Rust
   use [[~/hodal/emacs/property-dump.el][property-dump]]
