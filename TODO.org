* moves
Move default_metadata from tests/render_util.rs to
rust/types/new.rs.
* replace
In a number of places there's a passage like this:

+        HeadlineMd2 {
+          id : None,
+          relToOrgParent : RelToOrgParent2::SearchResult,
+          cycle : false,
+          focused : false,
+          folded : false,
+          mightContainMore : false,
+          repeat : false,
+          toDelete : false,
+        },

It would be less verbose if, in such places,
we just created an HeadlineMd2 using default_metadata,
and then replaced the one or two fields different from the default.
* Once the new works, anything unused in the old gets deleted.
  I suspect that includes all of rust/text_to_orgnodes/.
* DONE refactor: retain tree
  serial, control flow
** buffer to orgnode forest
*** refuse and report all problems if any of these happen
**** a node appears twice without 'rep' or 'mightContainMore'.
**** an AliasColl node has a body, or a child with an ID
**** an Alias node has a body, or children
**** a node is marked 'delete' somewhere but not everywhere
**** a node has multiple AliasCol children
**** a node's contents are defined more than once
     exception: they can be appended to any number of times
*** assign IDs where needed
    see assign_ids_recursive
*** assign rel_to_parent=Alias where needed
** Forest<OrgNode2> -> Set<(SkgNode,NodeSaveAction)>
** collect SKgNodes with the same ID
** update_fs_and_dbs2
   uses the Set<(SkgNode,NodeSaveAction)>
*** TypeDB : update_nodes_and_relationships2
*** FS
**** delete all to-delete nodes
**** write all non-delete nodes
     as normal, but filtering to only those nodes
*** update_index_from_save_instructions
    Delete every entry for which the id is any toDelete id.
      not just the pid
    Add as normal.
* TODO replace all uses of orgnode with orgnode2, etc.
  Do it all at once:
** can use
*** OrgNode2
*** RelToOrgParent2
*** HeadlineMd2
** can't use
*** OrgNode
*** RelToOrgParent
*** NodeWithEphem
*** MetadataItem
*** OrgNodeMetadata
*** OrgNodeInterp
* ONGOING git diff main 4a6c10735efdf59b
** new types
*** pub type SaveInstruction = (SkgNode, NodeSaveAction);
*** pub struct NodeSaveAction {
  pub mightContainMore: bool,
  pub toDelete: bool,
}
*** pub struct OrgNode2 {
  pub metadata: HeadlineMd2,
  pub title: String,
  pub body: Option<String>,
}
*** pub struct HeadlineMd2 {
  pub id: Option<ID>,
  pub relToOrgParent: RelToOrgParent2,
  pub cycle: bool,
  pub focused: bool,
  pub folded: bool,
  pub mightContainMore: bool,
  pub repeat: bool,
  pub toDelete: bool,
}
*** pub enum RelToOrgParent2 {
  Content,
  Container,
  AliasCol,
  Alias,
  None,
}
*** pub enum SaveError {
  ParseError(String),
  DatabaseError(Box<dyn Error>),
  InconsistentInstructions {
    inconsistent_deletions: Vec<ID>,
    multiple_definers: Vec<ID>,
  },
}
*** pub type HeadlineInfo = (usize, Option<HeadlineMd2>, String);
*** pub enum Buffer_Cannot_Be_Saved {
  // (content not fully visible in diff)
}

** field name changes in existing types
*** OrgNodeMetadata fields renamed:
  might_contain_more -> mightContainMore
  rel_to_parent -> relToOrgParent
* I regret not having asked for a refactoring plan.
* What {functions,types} bundle separble concerns?
** NodeWithEphem
* retain metadata when replacing node
  When a backview replaces text,
  it should retain the origin headline's
  relationship to its org-parent.
* link-sourceward view
** then eliminate further redundancy, if any
* generalize the Rust backpath rendering function
  Takes a lambda involving (probably)
    path_to_end_cycle_and_or_branches,
  and a starting level.
  The lambda can drop the first member of the path, or not.
* create new data without fetching preexisting data
  and add an integration test.
  Use a temp config, and delete it if the test passes.
* integration test for containerward view
* [[id:ba8fbc06-bb9c-4d69-bb1c-34cd1f80fdf4][multiple level-1 branches]]
* override the ordinary save command
* If there is a containerward "}" herald, the "ID exists" herald can be omitted.
* [[id:28d61c54-d474-4828-8ef9-e83b25c12ae8][heralds: more properties]]
  esp. rootness and multiple containment
* [[id:fb72f38e-bef6-4de9-a29b-00f0e46afbbb][deletion]]
* [[id:bc8fd4c3-0566-400c-96a8-0f4632e7fd1c][merging]]
* A node's ID should probably always be its primary one.
  In the medatata?
  As its name in the filesystem?
* retain focus, folding on save
** `org_from_node_recursive` should use its `focus` argument.
   This seems easy.
* not pressing
** refactoring
*** Parse metadata in Rust, not Emacs.
    see `skg-get-current-headline-metadata`
*** use s-exp parsing
**** in rust/serve/containerward_view.rs
     fn extract_containerward_view_params
**** in rust/serve/node_aliases.rs
     fn extract_node_aliases_params
**** in rust/serve/util.rs
***** definitely
      fn request_type_from_request (
      fn node_id_from_single_root_view_request (
      fn search_terms_from_request (
***** and maybe
      fn extract_quoted_value_from_sexp (
*** move empty_skgnode from tests into skgnode.rs
    and then use it for lots of tests
*** Use anyhow or eyre crates for better error handling
**** Cargo.toml
  anyhow = "1.0"
**** usage
  use anyhow::Context;

  let driver = TypeDBDriver::new(...)
      .await
      .context("Failed to connect to TypeDB server")?;
*** Avoid uses of `unwrap` in Rust.
*** find 'panic's, replace with Result
*** once it's possible, make a good pids_from_ids
    see [[./not_using/pids_from_ids]]
** fancy features
*** show binary relationship label with optional intermediating node
    esp. nice if you can filter on those labels,
    or on an ontology they belong to that groups them
*** show when a link is bi-directional
*** list which links are in a node's recursive content
*** [[id:e6e855d9-f2e8-456e-87d7-e82379ead9f1][show co-targeters, co-ancestors]]
* idiot-proof the save mechanism
** Collect all duplicated nodes.
   The user might have edited the contents of each,
   even though they're not supposed to.
   If they have, keep the first one's title,
   add a warning about the title conflict if any
   to the warnings being accumulated,
   collect all of its contents from the different instances,
   and dedup that collection.
* document
** that filenames must correspond to PIDs
** the dangers of repeated nodes to the user
   The original data model was that each node would have only one container. That proved infeasible, because the user can copy data at will. So skg accepts such data. But bear in mind that it is dangerous. The danger is this: If a node has branches, and is copied somewhere earlier in the same document, then that new copy will take precedence. Edits to it will be treated as *the* edits. If all you did was copy the node but not its branches, its branches will be lost when you save.
** find where to put this comment
 // Titles can include hyperlinks,
 // but can be searched for as if each hyperlink
 // was equal to its label, thanks to replace_each_link_with_its_label.
** change graph -> web
** drop [[../docs/progress.md][progress.md]]
** Didactically, concept maps > knowledge graph.
** [[../docs/data-model.md][The data model]] and [[../docs/sharing-model.md][The sharing model]] overlap
   as documents.
* solutions
** to extract Emacs properties into Rust
   use [[~/hodal/emacs/property-dump.el][property-dump]]
