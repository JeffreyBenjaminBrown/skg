# Commit 146199b3: Node Merge Algorithm Implementation

## Purpose

This commit implements the ability to merge two nodes in the knowledge graph. When nodes are merged, one node (the "acquirer") absorbs another node (the "acquiree"), combining their identities, relationships, and contents while preserving the acquiree's original text.

## Conceptual Model

A merge operation transforms the graph as follows:

**Before merge:**
- Node A (acquirer): has ID_A, some contents, some relationships
- Node B (acquiree): has ID_B, some contents, some relationships

**After merge:**
- Node A' (updated acquirer): has IDs [ID_A, ID_B], combined contents and relationships
- Node C (acquiree_text_preserver): new node with ID_C, contains B's title and body text
- Node B: deleted
- A' contains C as its first child

The key insight is that a merge produces **three SaveInstructions** (create, update, delete) rather than just updating two nodes.

## Type System Changes

### SkgNode Optional Fields

Three fields in `SkgNode` changed from `Vec<ID>` to `Option<Vec<ID>>`:

```rust
pub struct SkgNode {
    // ... other fields
    pub subscribes_to: Option<Vec<ID>>,              // was Vec<ID>
    pub hides_from_its_subscriptions: Option<Vec<ID>>, // was Vec<ID>
    pub overrides_view_of: Option<Vec<ID>>,          // was Vec<ID>
}
```

**Semantic distinction:**
- `None`: User did not specify this field; preserve existing disk value
- `Some(vec![])`: User explicitly set empty list; replace disk value with empty list
- `Some(vec![id1, id2])`: User specified IDs; replace disk value with these IDs

This enables the "none fields are noops" behavior where unspecified fields don't overwrite existing data.

### NodeRequest::Merge

New variant added to the `NodeRequest` enum:

```rust
pub enum NodeRequest {
    SourcewardView,
    Merge(ID),  // NEW: ID of the node to be acquired
}
```

Users can request a merge by including `(merge "target-id")` in the node's metadata.

## Algorithm Structure

The merge algorithm consists of three main phases:

1. **SaveInstruction Generation**: Convert merge requests in OrgNodes into SaveInstructions
2. **TypeDB Update**: Reroute relationships and update entities in the graph database
3. **Filesystem Update**: Write/delete .skg files
4. **Tantivy Update**: Update the search index

### Phase 1: SaveInstruction Generation

**Entry point:** `instructiptriples_from_the_merges_in_an_orgnode_forest`

For each node in the orgnode forest:
1. Check if node has `NodeRequest::Merge(acquiree_id)` in its metadata
2. If yes, call `saveinstructions_from_the_merge_in_a_node`

**For each merge request:**

1. **Extract IDs:**
   - `acquirer_id` = node's current ID (must exist)
   - `acquiree_id` = target ID from merge request

2. **Read from disk:**
   - `acquirer_from_disk` = read acquirer's current .skg file
   - `acquiree_from_disk` = read acquiree's current .skg file

3. **Create acquiree_text_preserver:**
```rust
SkgNode {
    title: format!("MERGED-{}", acquiree.title),
    aliases: None,
    ids: vec![new_uuid()],
    body: acquiree.body.clone(),
    contains: vec![],
    subscribes_to: Some(vec![]),
    hides_from_its_subscriptions: Some(vec![]),
    overrides_view_of: Some(vec![]),
}
```

4. **Create updated_acquirer:**
```rust
SkgNode {
    // ... copy most fields from acquirer_from_disk
    ids: acquirer_from_disk.ids + deduplicated(acquiree_from_disk.ids),
    contains: [acquiree_text_preserver_id]
              + acquirer_from_disk.contains
              + acquiree_from_disk.contains,
    // Other relationship fields combined later in fs.rs
}
```

5. **Create deleted_acquiree:**
```rust
(acquiree_from_disk, NodeSaveAction { toDelete: true, indefinitive: false })
```

6. **Return three SaveInstructions** in order:
   - (acquiree_text_preserver, create action)
   - (updated_acquirer, update action)
   - (deleted_acquiree, delete action)

**Recognition pattern:** Later phases identify merge instructions by detecting nodes with titles starting with "MERGED-", then treating the next two instructions as the updated_acquirer and deleted_acquiree.

### Phase 2: TypeDB Update

**Entry point:** `merge_nodes_in_typedb`

All merges are executed in a **single TypeDB transaction** for atomicity.

For each merge, execute these steps **in order:**

#### Step 1: Reroute `contains` relationships (bilateral)

```typeql
# Acquiree as container → acquirer as container
match
  $acquiree isa node, has id "{acquiree_id}";
  $acquirer isa node, has id "{acquirer_id}";
  $c isa node;
  $contains_rel isa contains (container: $acquiree, contained: $c);
delete $contains_rel;
insert
  $new_contains_rel isa contains (container: $acquirer, contained: $c);

# Acquiree as contained → acquirer as contained
match
  $acquiree isa node, has id "{acquiree_id}";
  $acquirer isa node, has id "{acquirer_id}";
  $container isa node;
  $contains_rel isa contains (container: $container, contained: $acquiree);
delete $contains_rel;
insert
  $new_contains_rel isa contains (container: $container, contained: $acquirer);
```

**Both roles transferred:** Container role and contained role.

#### Step 2: Reroute `subscribes` relationships (bilateral)

```typeql
# Acquiree as subscriber → acquirer as subscriber
match
  $acquiree isa node, has id "{acquiree_id}";
  $acquirer isa node, has id "{acquirer_id}";
  $s isa node;
  $sub_rel isa subscribes (subscriber: $acquiree, subscribee: $s);
delete $sub_rel;
insert
  $new_sub_rel isa subscribes (subscriber: $acquirer, subscribee: $s);

# Acquiree as subscribee → acquirer as subscribee
match
  $acquiree isa node, has id "{acquiree_id}";
  $acquirer isa node, has id "{acquirer_id}";
  $s isa node;
  $subee_rel isa subscribes (subscriber: $s, subscribee: $acquiree);
delete $subee_rel;
insert
  $new_subee_rel isa subscribes (subscriber: $s, subscribee: $acquirer);
```

**Both roles transferred:** Subscriber role and subscribee role.

#### Step 3: Reroute `overrides_view_of` relationships (asymmetric)

```typeql
# Acquiree as replacement → acquirer as replacement (TRANSFER)
match
  $acquiree isa node, has id "{acquiree_id}";
  $acquirer isa node, has id "{acquirer_id}";
  $replaced_node isa node;
  $rel_old isa overrides_view_of (replacement: $acquiree, replaced: $replaced_node);
delete $rel_old;
insert
  $rel_new isa overrides_view_of (replacement: $acquirer, replaced: $replaced_node);

# Acquiree as replaced → DROP (do not recreate)
match
  $acquiree isa node, has id "{acquiree_id}";
  $replacement_node isa node;
  $rel_drop isa overrides_view_of (replacement: $replacement_node, replaced: $acquiree);
delete $rel_drop;
```

**Asymmetric handling:**
- Replacement role: transferred to acquirer
- Replaced role: dropped (not recreated)

**Rationale:** If something was overriding the acquiree's view, that relationship becomes meaningless since the acquiree no longer exists as a separate viewable entity.

#### Step 4: Reroute `hides_from_its_subscriptions` relationships (complex, conditional)

This is the most complex rerouting operation with conditional logic.

**Part A: Acquiree as hidden → DROP**

```typeql
match
  $acquiree isa node, has id "{acquiree_id}";
  $h isa node;
  $r isa hides_from_its_subscriptions (hider: $h, hidden: $acquiree);
delete $r;
```

**No transfer:** If acquiree was hidden from some node's subscriptions, don't transfer this. The acquiree no longer exists as a separate entity.

**Part B: Acquiree as hider → CONDITIONAL TRANSFER**

```typeql
# First, query all nodes that acquiree was hiding
match
  $acquiree isa node, has id "{acquiree_id}";
  $r isa hides_from_its_subscriptions (hider: $acquiree, hidden: $hidden);
  $hidden has id $hidden_id;
select $hidden_id;
```

For each `hidden_id` returned:

```rust
if !acquirer_final_contains.contains(&hidden_id) {
    // Transfer: acquirer now hides this node
    match
      $acquirer isa node, has id "{acquirer_id}";
      $hidden isa node, has id "{hidden_id}";
      $acquiree isa node, has id "{acquiree_id}";
      $old_r isa hides_from_its_subscriptions (hider: $acquiree, hidden: $hidden);
    delete $old_r;
    insert
      $new_r isa hides_from_its_subscriptions (hider: $acquirer, hidden: $hidden);
} else {
    // Drop: acquirer can't hide its own content
    match
      $acquiree isa node, has id "{acquiree_id}";
      $hidden isa node, has id "{hidden_id}";
      $old_r isa hides_from_its_subscriptions (hider: $acquiree, hidden: $hidden);
    delete $old_r;
}
```

**Conditional logic:** Transfer the "hides" relationship ONLY if the hidden node is NOT in the acquirer's final `contains` list. You cannot hide your own content from subscriptions.

#### Step 5: Reroute `hyperlinks_to` relationships (incoming only)

```typeql
# Acquiree as dest → acquirer as dest (incoming hyperlinks)
match
  $acquiree isa node, has id "{acquiree_id}";
  $acquirer isa node, has id "{acquirer_id}";
  $source isa node;
  $hyperlink_rel isa hyperlinks_to (source: $source, dest: $acquiree);
delete $hyperlink_rel;
insert
  $new_hyperlink_rel isa hyperlinks_to (source: $source, dest: $acquirer);
```

**Incoming only:** Outbound hyperlinks (where acquiree is source) are NOT rerouted.

**Rationale:** Outbound hyperlinks originate from the acquiree's body text, which is preserved in `acquiree_text_preserver`. Those hyperlinks should remain pointing from the preserved text node, not from the acquirer.

#### Step 6: Delete acquiree's extra_ids

```typeql
# Query all extra_ids for the acquiree
match
  $node isa node, has id "{acquiree_id}";
  $e isa extra_id;
  $rel isa has_extra_id (node: $node, extra_id: $e);
  $e has id $extra_id_value;
select $extra_id_value;

# For each extra_id_value, delete the extra_id entity
match
  $e isa extra_id, has id "{extra_id_value}";
delete $e;
```

**Order dependency:** Must happen BEFORE deleting the acquiree node (entity must exist for relationship traversal) and BEFORE adding acquiree's IDs as extra_ids to the acquirer (to avoid conflicts).

#### Step 7: Delete acquiree node

```typeql
match
  $node isa node, has id "{acquiree_id}";
delete $node;
```

Simple deletion of the acquiree entity.

#### Step 8: Create acquiree_text_preserver node

Call `create_node(acquiree_text_preserver, tx)` which inserts the new node entity and its ID attribute.

Then call `create_relationships_from_node(acquiree_text_preserver, tx)` which creates:
- Any hyperlinks found in the acquiree_text_preserver's body text
- Other relationships (though most are empty for this node)

#### Step 9: Create contains relationship

```typeql
match
  $acquirer isa node, has id "{acquirer_id}";
  $preserver isa node, has id "{acquiree_text_preserver_id}";
insert
  $contains_rel isa contains (container: $acquirer, contained: $preserver);
```

Makes acquirer contain the acquiree_text_preserver as its first child.

#### Step 10: Add acquiree's IDs as extra_ids

For each ID in `acquiree.ids`:

```typeql
match
  $acquirer isa node, has id "{acquirer_id}";
insert
  $e isa extra_id, has id "{extra_id_value}";
  $r isa has_extra_id (node: $acquirer, extra_id: $e);
```

This makes all of the acquiree's IDs (both primary and any extra_ids it had) become extra_ids of the acquirer.

**Order dependency:** Must happen AFTER deleting the acquiree's extra_ids to avoid trying to create duplicate extra_id entities.

#### Transaction Commit

After processing all merges in the batch, commit the transaction:

```rust
tx.commit().await?;
```

If any step fails, the transaction is rolled back and no changes are persisted to TypeDB.

### Phase 3: Filesystem Update

**Entry point:** `merge_nodes_in_fs`

For each merge (identified by the categorization pattern):

#### Step 1: Write acquiree_text_preserver

```rust
let path = path_from_pid(&config, acquiree_text_preserver.ids[0]);
write_node(acquiree_text_preserver, &path)?;
```

Creates a new .skg file for the text preserver node.

#### Step 2: Compute final acquirer relationships

The updated_acquirer from phase 1 already has:
- Combined IDs
- Combined contains (with acquiree_text_preserver first)

Now compute the other relationship fields:

```rust
// Combine subscribes_to
acquirer_to_write.subscribes_to = Some(
    updated_acquirer.subscribes_to.unwrap_or_default()
      .chain(acquiree.subscribes_to.unwrap_or_default())
      .collect()
);

// Combine hides_from_its_subscriptions (with filtering)
let acquirer_final_contains: HashSet<ID> =
    updated_acquirer.contains.iter().cloned().collect();

let mut combined_hides = vec![];
for hides_list in [updated_acquirer.hides_from_its_subscriptions,
                   acquiree.hides_from_its_subscriptions] {
    if let Some(list) = hides_list {
        for hidden_id in list {
            if !acquirer_final_contains.contains(&hidden_id)
               && !combined_hides.contains(&hidden_id) {
                combined_hides.push(hidden_id);
            }
        }
    }
}
acquirer_to_write.hides_from_its_subscriptions = Some(combined_hides);

// Combine overrides_view_of
acquirer_to_write.overrides_view_of = Some(
    updated_acquirer.overrides_view_of.unwrap_or_default()
      .chain(acquiree.overrides_view_of.unwrap_or_default())
      .collect()
);
```

**Key filtering rule:** When combining `hides_from_its_subscriptions`, exclude any IDs that are in `acquirer_final_contains`. You cannot hide your own content.

#### Step 3: Write updated acquirer

```rust
let path = path_from_pid(&config, acquirer_to_write.ids[0]);
write_node(&acquirer_to_write, &path)?;
```

Overwrites the existing .skg file with the updated node data.

#### Step 4: Delete acquiree file

```rust
let path = path_from_pid(&config, acquiree.ids[0]);
std::fs::remove_file(&path)?;
```

Removes the acquiree's .skg file from the filesystem.

### Phase 4: Tantivy Update

**Entry point:** `merge_nodes_in_tantivy`

This phase delegates to the existing `update_index_from_saveinstructions` function:

```rust
let tantivy_index = TantivyIndex {
    index: Arc::new(index.clone()),
    id_field: schema.get_field("id")?,
    title_or_alias_field: schema.get_field("title_or_alias")?,
};

update_index_from_saveinstructions(instructions, &tantivy_index)?;
```

The existing function handles SaveInstructions by:
1. Deleting all IDs mentioned in the instructions from the index
2. Re-adding documents for non-deleted nodes
3. Skipping deleted nodes

This correctly handles merges:
- Deletes: acquirer (old version), acquiree, acquiree_text_preserver (not yet in index)
- Re-adds: acquirer (new version with extra IDs), acquiree_text_preserver (new)
- Skips: acquiree (marked toDelete)

## Integration Points

### Parsing Merge Requests

In `parse_headline_md_sexp.rs`, the parser was extended to handle merge requests:

```rust
// In parse_requests_sexp function
match sexp {
    Sexp::Atom(_) => {
        // ... existing atom handling for other requests
    },
    Sexp::List(list_items) if list_items.len() == 2 => {
        let command = atom_to_string(&list_items[0])?;
        if command == "merge" {
            let id_str = atom_to_string(&list_items[1])?;
            requests.insert(NodeRequest::Merge(ID::from(id_str)));
        }
    },
    // ... error handling
}
```

This allows users to write: `(skg (id "abc") (requests (merge "xyz")))`

### Rebuild Handling

In `rebuild.rs`, merge requests are explicitly ignored during view operations:

```rust
NodeRequest::Merge(_) => {
    // Merge requests are handled during save, not rebuild/view
}
```

Merges only take effect when the user saves, not when viewing.

### None Field Handling

In `none_node_fields_are_noops.rs`, the logic was extended to handle the three new Option fields:

```rust
if result.subscribes_to.is_none() {
    result.subscribes_to = disk_node.subscribes_to;
}
if result.hides_from_its_subscriptions.is_none() {
    result.hides_from_its_subscriptions = disk_node.hides_from_its_subscriptions;
}
if result.overrides_view_of.is_none() {
    result.overrides_view_of = disk_node.overrides_view_of;
}
```

This ensures that when creating SaveInstructions from OrgNodes, unspecified relationship fields don't overwrite existing data on disk.

## Critical Order Dependencies

1. **Within TypeDB merge:**
   - Delete acquiree's extra_ids BEFORE deleting acquiree node
   - Delete acquiree node BEFORE creating extra_ids for acquirer
   - Create acquiree_text_preserver BEFORE creating contains relationship

2. **Across systems:**
   - TypeDB BEFORE filesystem (TypeDB is authoritative)
   - Filesystem BEFORE Tantivy (Tantivy can be rebuilt from filesystem)

3. **Within SaveInstruction generation:**
   - Instructions must be in order: [acquiree_text_preserver, updated_acquirer, deleted_acquiree]
   - This pattern enables the categorization function to identify merge instructions

## Edge Cases and Special Handling

### Filtering Hidden Nodes

When a node hides another node from its subscriptions, but then acquires that node through a merge, the hiding relationship is dropped:

```rust
if !acquirer_final_contains.contains(&hidden_id) {
    // Transfer the hiding relationship
} else {
    // Drop it - can't hide your own content
}
```

### Asymmetric Override Rerouting

When something overrides the acquiree's view, that relationship is dropped because the acquiree no longer has a separate view:

```
// Transfer: acquiree overrides X → acquirer overrides X
// Drop: Y overrides acquiree → deleted (not: Y overrides acquirer)
```

### Hyperlink Directionality

Incoming hyperlinks are rerouted to the acquirer (so links to the acquiree now point to the merged result), but outbound hyperlinks stay with the acquiree_text_preserver (since they originate from that text).

### ID Accumulation

All of the acquiree's IDs (both its primary ID and any extra_ids it had) become extra_ids of the acquirer. This ensures that any references to the acquiree by any of its IDs will find the acquirer.

### Empty Relationships for Text Preserver

The acquiree_text_preserver is created with explicitly empty relationship fields:

```rust
subscribes_to: Some(vec![]),
hides_from_its_subscriptions: Some(vec![]),
overrides_view_of: Some(vec![]),
```

It has no subscription or override relationships, only containment (as a child of the acquirer) and potential hyperlinks from its body text.

## Error Handling and Atomicity

**TypeDB:** Single transaction provides atomicity. If any merge step fails, the entire transaction is rolled back.

**Filesystem:** No transaction mechanism. If writing fails midway, filesystem is in an inconsistent state.

**Tantivy:** No transaction mechanism. If indexing fails, the index is stale but can be rebuilt.

**Cross-system:** If TypeDB succeeds but filesystem or Tantivy fails, the system is in an invalid state with no automatic recovery mechanism. The error propagates to the caller.

## Categorization Algorithm

The `categorize_merge_instructions` function identifies merge instructions from a SaveInstruction list:

```rust
let mut i = 0;
while i < instructions.len() {
    let instr = &instructions[i];

    if instr.0.title.starts_with("MERGED-") {
        // This is acquiree_text_preserver
        acquiree_text_preservers.push(instr);

        // Next is updated_acquirer
        if i + 1 < instructions.len() {
            updated_acquirers.push(&instructions[i + 1]);
        }

        // Next is deleted_acquiree
        if i + 2 < instructions.len() {
            deleted_acquirees.push(&instructions[i + 2]);
        }

        i += 3;  // Skip the three-instruction merge block
    } else {
        i += 1;  // Regular instruction, move to next
    }
}
```

This pattern matching allows the three subsystems (TypeDB, filesystem, Tantivy) to process the same SaveInstruction list and extract the relevant merge operations.

## Summary

The merge algorithm implements a three-component transformation (create/update/delete) that:

1. **Preserves** the acquiree's text content in a new node
2. **Combines** the identities, contents, and relationships of both nodes in the acquirer
3. **Reroutes** relationships according to type-specific rules:
   - Bilateral transfer: contains, subscribes
   - Asymmetric transfer: overrides_view_of
   - Conditional transfer: hides_from_its_subscriptions
   - Incoming-only transfer: hyperlinks_to
4. **Updates** three systems in sequence: TypeDB (authoritative), filesystem (persistent), Tantivy (indexing)
5. **Maintains** referential integrity by making all acquiree IDs resolve to the acquirer

The implementation prioritizes correctness and atomicity in TypeDB, with the acknowledgment that filesystem and Tantivy updates lack transaction support and could leave the system in an inconsistent state if they fail after TypeDB succeeds.
