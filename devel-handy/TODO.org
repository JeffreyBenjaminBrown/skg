* new types
enum NodeSaveAction = {
  might_contain_more : bool,
  to_delete          : bool,
struct OrgNode2 = {
  metadata : OrgNodeMd2,
  title    : String,
  body     : String }
struct OrgNodeMd2 = {
  id                 : Option<ID>,
  rel_to_parent      : RelToOrgParent2,
  cycle              : bool,
  focused            : bool,
  folded             : bool,
  might_contain_more : bool,
  repeat             : bool,
  to_delete          : bool, }
enum RelToOrgParent2 = {
  Conent, Container, AliasColl, Alias, None }
* refactor: retain tree
  serial, control flow
** interpret_org_node2
*** refuse and report all problems if any of these happen
**** an AliasColl node has a body or a child with an ID
**** an Alias node has a body
**** a node is marked 'delete' somewhere but not everywhere
*** continue but report all problems if any of these happen
**** an alias node has children
     They will be saved, perhaps becoming new roots.
*** assign IDs where needed
    see assign_ids_recursive
*** assign rel_to_parent=Alias where needed
*** Forest<OrgNode2> -> Set<(SkgNode,NodeSaveAction)>
*** Collect from all AliasColls, rather than keeping only the first.
*** Collect all duplicated nodes.
    The user might have edited the contents of each,
    even though they're not supposed to.
    If they have, keep the first one's title,
    add a warning about the title conflict if any
    to the warnings being accumulated,
    collect all of its contents from the different instances,
    and dedup that collection.
*** Any child of an alias is assigned RelToOrgParent2 = None.
** clobber the Set<(SkgNode,NodeSaveAction)>
   See 'clobber_none_fields_with_data_from_disk'.
   Extend to also add extra-ids.
   Do something similar for content,
     if SkgNodeSaveAction.might_contain_more == true.
** update_fs_and_dbs2
   uses the Set<(SkgNode,NodeSaveAction)>
*** TypeDB : update_nodes_and_relationships2
    First, for each to_delete node,
      delete every node using that ID, even if as an extra_id.
    Do the rest of the existing update_nodes_and_relationships
      only to the other nodes.
*** FS
**** write all non-delete nodes
     as normal, but filtering to only those nodes
**** delete all to-delete nodes
*** update_index_with_nodes
    Delete every entry for which the id is any to_delete id.
      not just the pid
    Add as normal.
** rebuild view
*** will build a Forest<OrgNode2> based on the original one
*** The result begins as a copy of the original one.
*** Process it DFS.
*** Keep a running tally of which nodes have already been processed.
*** recompute the following metadata values
**** cycle
     based on the breadcrumbs to root
**** rel_to_parent
     Verify Container relationships. If the relationship is no more,
     replace rel_to_parent=None.
**** might_contain_more defaults to true sometimes
* Look at all my plans, and the code around saving, and ask what makes each difficult.
  Do this to know how to change the data structure,
  and likely the control flow.
* Navigate the tree in Rust as a tree.
* What {functions,types} bundle separble concerns?
** NodeWithEphem
* retain metadata when replacing node
  When a backview replaces text,
  it should retain the origin headline's
  relationship to its org-parent.
* link-sourceward view
** then eliminate further redundancy, if any
* generalize the Rust backpath rendering function
  Takes a lambda involving (probably)
    path_to_end_cycle_and_or_branches,
  and a starting level.
  The lambda can drop the first member of the path, or not.
* create new data without fetching preexisting data
  and add an integration test.
  Use a temp config, and delete it if the test passes.
* [[id:ba8fbc06-bb9c-4d69-bb1c-34cd1f80fdf4][multiple level-1 branches]]
* override ordinary save command
* If there is a containerward "}" herald, the "ID exists" herald can be omitted.
* [[id:28d61c54-d474-4828-8ef9-e83b25c12ae8][heralds: more properties]]
  esp. rootness and multiple containment
* [[id:fb72f38e-bef6-4de9-a29b-00f0e46afbbb][deletion]]
* [[id:bc8fd4c3-0566-400c-96a8-0f4632e7fd1c][merging]]
* A node's ID should probably always be its primary one.
  In the medatata?
  As its name in the filesystem?
* retain focus, folding on save
** `org_from_node_recursive` should use its `focus` argument.
   This seems easy.
* not pressing
** refactoring
*** Parse metadata in Rust, not Emacs.
    see `skg-get-current-headline-metadata`
*** use s-exp parsing
**** in rust/serve/containerward_view.rs
     fn extract_containerward_view_params
**** in rust/serve/node_aliases.rs
     fn extract_node_aliases_params
**** in rust/serve/util.rs
***** definitely
      fn request_type_from_request (
      fn node_id_from_single_root_view_request (
      fn search_terms_from_request (
***** and maybe
      fn extract_quoted_value_from_sexp (
*** move empty_skgnode from tests into skgnode.rs
    and then use it for lots of tests
*** Use anyhow or eyre crates for better error handling
**** Cargo.toml
  anyhow = "1.0"
**** usage
  use anyhow::Context;

  let driver = TypeDBDriver::new(...)
      .await
      .context("Failed to connect to TypeDB server")?;
*** Avoid uses of `unwrap` in Rust.
** fancy features
*** show binary relationship label with optional intermediating node
    esp. nice if you can filter on those labels,
    or on an ontology they belong to that groups them
*** show when a link is bi-directional
*** list which links are in a node's recursive content
*** [[id:e6e855d9-f2e8-456e-87d7-e82379ead9f1][show co-targeters, co-ancestors]]
* document
** that filenames must correspond to PIDs
** the dangers of repeated nodes to the user
   The original data model was that each node would have only one container. That proved infeasible, because the user can copy data at will. So skg accepts such data. But bear in mind that it is dangerous. The danger is this: If a node has branches, and is copied somewhere earlier in the same document, then that new copy will take precedence. Edits to it will be treated as *the* edits. If all you did was copy the node but not its branches, its branches will be lost when you save.
** find where to put this comment
 // Titles can include hyperlinks,
 // but can be searched for as if each hyperlink
 // was equal to its label, thanks to replace_each_link_with_its_label.
** change graph -> web
** drop [[../docs/progress.md][progress.md]]
** Didactically, concept maps > knowledge graph.
** [[../docs/data-model.md][The data model]] and [[../docs/sharing-model.md][The sharing model]] overlap
   as documents.
* solutions
** to extract Emacs properties into Rust
   use [[~/hodal/emacs/property-dump.el][property-dump]]
