* Rerun herald-apply only on the changed line.
* rewrite client entirely
** Rust sends text including bullets, not sexps.
*** Worry later about
**** escaping quotes
**** communicating fold state
*** In each headline, after the bullet, appears <<skg: ...>>,
    where the ... includes:
**** id:ID
**** "repeated", if applicable
** How Emacs displays the received text
*** the ID and "repeated" are fewer characters
**** ID : a single "â…„" character, white text on black
**** "repeated" : REP, white text on red
*** other things are wysiwyg
**** hyperlinks: normal (blue, underlined)
**** other text: normal
*** nothing is read-only
** The user can delete important stuff.
   Whatever. It's on them.
** How Emacs returns text to Rust.
   Exactly as it's stored in the buffer,
   but not as it's displayed.
** How Rust interprets the received text
   straightforward
** How it can be extended
*** show heralds
    number of backlinks
    number of contents
    multiple containers
*** show backlinks
**** what Rust sends : no danger
***** each backlink's hidden text has "<<id:_,links to org-parent>>"
**** how Emacs shows it
***** they are immediate org-children
***** their backlink-ness is indicated with a system "<"
**** what Rust receives, it ignores
     :PROPERTIES:
     :ID:       1a782972-ebda-4f77-aa3e-934cea201409
     :END:
     Emacs sends them back to Rust on save, but Rust ignores them.
     (Emacs could filter them out,
     but I want to shift all processing possible to Rust from Emacs.)
**** the user can only screw it up by editing the hidden text
     :PROPERTIES:
     :ID:       b4e7971e-7f7b-4989-bdd1-ce6cabccc710
     :END:
***** if they put the backlink somewhere else, no harm, because backlinks are ignored on save
***** if they edit* the hidden text, who cares, that's on them
      editing here includes deletion
*** show ancestries
**** what Rust sends : no danger
***** each ancestry's hidden text has "<<id:_,contains org-parent>>"
**** how Emacs shows it
***** each* ancestry is an immediate org-child
      hopefully there's only one, but nothing enforces that
***** the `contains org-parent` tag translates to a "}" herald
**** [[id:1a782972-ebda-4f77-aa3e-934cea201409][what Rust receives, it ignores]]
**** [[id:b4e7971e-7f7b-4989-bdd1-ce6cabccc710][the user can only screw it up by editing the hidden text]]
*** merge
*** show when a link is bi-directional
*** list which links are in its recursive contents
*** hide content
    should manifest as an H in the container's headline
*** [[id:e6e855d9-f2e8-456e-87d7-e82379ead9f1][show cotargeters, coancestors]]
* emacs ideas, meh
** skg-doc-insert-node seems worth redoing.
   I want to favor real (but hideable) text over text properties.
   `repeated`, for instance, should be real text.
** I don't need to salvage the test suite's structure.
   The tests themselves could be worth saving,
   but the structure can be scrapped.
** Use AI to make the test harness reasonably-structured.
** I don't need to use lots of properties.
   Maybe hidden-ness alone would work.
** Let the user be responsible for avoiding duplication.
   Don't make it impossible -- too hard.
   But do make it investigable, both in a view,
   and in saved changes.
* Where is the API for the orgnode sexp format?
  If it does not exist, it ought to,
  and the files in rust/save/ ought to reference it.
* Avoid uses of `unwrap` in Rust.
* Explain the dangers of repeated nodes to the user.
  The original data model was that each node would have only one container. That proved infeasible, because the user can copy data at will. So skg accepts such data. But bear in mind that it is dangerous. The danger is this: If a node has branches, and is copied somewhere earlier in the same document, then that new copy will take precedence. Edits to it will be treated as *the* edits. If all you did was copy the node but not its branches, its branches will be lost when you save.
* find where to put this comment
// Titles can include hyperlinks,
// but can be searched for as if each hyperlink
// was equal to its label, thanks to replace_each_link_with_its_label.
* extract into a config file
** let db_name = "skg-test";
   in rust/serve.rs
** "127.0.0.1:1729",
   in rust/serve.rs
   in elisp/, somewhere
** TcpListener::bind("0.0.0.0:1730")?;
   in rust/serve.rs
* change graph -> web
* see also [[../docs/progress.md][progress.md]]
* use [[~/hodal/emacs/property-dump.el][property-dump]] to send straight to Rust
* tests/org-to-sexp.el fails
Part of the problem is that search changes fold structure. The following replaces search with builtin org navigation functions, but I haven't got it to work yet.
** just the diff
modified   elisp/org-to-sexp.el
@@ -40,19 +40,15 @@ MOVES POINT to the first line after the body."
   (beginning-of-line)
   (let ((body-start (point))
         (body-end
-         ;; Find the next heading or end of buffer
-         (if (re-search-forward "^\\*+ " nil t)
-             (match-beginning 0)
-           (point-max))))
+         (save-excursion
+           (if (org-next-visible-heading 1)
+               (point)
+             (point-max)))))
     (when (< body-start body-end)
       (let ((body-text (string-trim-right
                         (buffer-substring-no-properties
                          body-start body-end))))
-        (if ;; Without this, if this body
-            ;; were the last thing in the file,
-            ;; point does not end up after it.
-            (= body-end (point-max))
-            (goto-char (point-max)))
+        (goto-char body-end)
         `(body . ,body-text)))))

 (defun org-to-sexp-parse-heading-at-point-and-maybe-body
** the entire function definition (new side of the diff)
(defun org-to-sexp-parse-body-at-point ()
  "RETURNS either nil or a string without properties,
of the form (body . STRING).
ASSUMES point is on the first line of a headline body.
MOVES POINT to the first line after the body."
  (beginning-of-line)
  (let ((body-start (point))
        (body-end
         (save-excursion
           (if (org-next-visible-heading 1)
               (point)
             (point-max)))))
    (when (< body-start body-end)
      (let ((body-text (string-trim-right
                        (buffer-substring-no-properties
                         body-start body-end))))
        (goto-char body-end)
        `(body . ,body-text)))))
* in the rust save code
  make sure it uses the same spec as elisp/org-to-sexp.el
* closing the read/save knot
** Why is this so hard?
** sketch
*** Update FS, DB, index (titles).
**** sketch
***** If ID is found in TypeDB
      Compare its text and its contents to the orgnode's.
      If either is different, rewrite the file.
      Keep info in the file not visible from the orgnode,
      esp. extra IDs.
***** otherwise
**** Don't obliterate extra ids!
     The FileNode created from an OrgNode will only have one ID.
     But that might just be one of the OrgNode's IDs.
*** Rebuild document
    with the same folded and focused nodes.
*** Send document.
** Keep the `repeated` field.
   When a document is created, `repeated` is sent to Emacs so that it knows to font the repeats differently from the original.
   It should be sent back to Rust to know whether to disregard a node's data. The user might move a node marked `repeated` to before the first (reference) node with that ID. Retaining this field permits Rust to know which one is the reference node.
** Rebuild the whole document when returning it.
   Less efficient but way easier.
** Retain a set of folded nodes, and the ID of the focused one.
** (OrgNode -> FileNode) -> (OrgNode -> (FileNode, ephemeral view data))
** use the `folded` field in OrgNode
   Rust will need this in order to restore state
   when it sends the document (with some new IDs)
   back to Emacs.
** write to disk, then Tantivy and TypeDB
*** update files
    Compare each FileNode received (after interpretation) from Emacs to the file it corresponds to. Read the TypeDB db to see if an ID (which might not be the primary one) corresponds to something extant.
    If the file is absent, create it.
    If the file differs in any way from the FileNode, update it.
    Keep a list of paths to all files modified or created. For files modified, track whether their text, content and/or hyperlinks have changed.
    Orphaned content becomes uncontained, not deleted.
*** update TypeDB
    If a file is new, load it as normal.
    Create relationships only after loading all entities (as is currently the case on initial load) so that all members of each relationship to create exist.
    If a file was modified, delete and recreate all of its out-links (hyperlinks, content, subscriptions). Change none of its other ("incoming") links.
*** to Tantivy
    If a file is new, load it as normal.
    If a file's text was modified, reload it.
** [[id:e707ded7-ff36-41cf-8ae1-672ab78e30d4][send new document from Rust]]
* in docs
** Didactically, concept maps > knowledge graph.
** [[../docs/data-model.md][The data model]] and [[../docs/sharing-model.md][The sharing model]] overlap
   as documents.
* maybe rename `contains` -> `presents`
* the db_name "skg-test" should not be hardcoded
* Tantivy checks if a file needs indexing (based on modification time) but TypeDB doesn't.
* the TODO item in rust/serve.rs
