;;; -*- lexical-binding: t; -*-
;;;
;;; PURPOSE: Transform s-expressions using pattern-matching rules

(require 'cl-lib)

(defun skg-transform-sexp-flat
  (object rules)
  "Applies 'rules' to 'object' to generate an output expression.
Has no side effects.
The test suite demonstrates how rules are interpreted,
perhaps better than the following explanation.
.
Both 'object' and 'rules' can be nested s-exps.
The first element of each s-expr at any level should be an atom,
which we'll usually call the 'label'.
(I say 'usually' because there's an exception:
if the expression includes a color directive,
as described below, then that precedes the label.
Both the color directive and the label are atoms.)
The rest of the list can be anything.
The leaf-lists (lists with no sublists) of a rule
contain, after the label, a series of symbols,
 which will be concatenated in the result with ':' between them.
.
Consider such a leaf-list in a rule, with two elts, 'a' and 'b'.
The rules indicates how to transform 'a' into 'b'.
('a' is a label in the rule but is an atom in the object.)
If the transformation applies, it is appended to the output expression.
The transformation only applies if the atom 'a' from 'rules'
can be found in 'object', and both are nested such that
the sequence of 'label's leading to each is the same.
  So for instance if object=(a (b c)) and rules=(a (b (c d))),
  the output would be 'd', but if rules had been (b (a (c d)))
  the output would instead be the empty list.
  (In the first case if the rule were instead '(a (b (c d e)))',
  the output would be 'd:e'.)
.
There are several keywords that receive special treatment:
ANY, IT, and the colors RED, GREEN, and BLUE.
.
ANY indicates that the path of labels exists.
Regardless of what the leaf sexp in the object at that path contains,
the elements listed after ANY in the corresponding leaf-sexp
of the rule will be appended to the output. This is true
even if the object leaf-sexp is a singleton,
containing only the label.
  So for instance, if our rule is (a (b (ANY x))),
  the output would be (x) for any of the following objects:
    (a (b))
    (a (b c))
    (a c (b c))
  whereas for these objects, the output would be ():
    (b a)
    (a b)
    (a)
.
In an ANY leaf-sexp in a rule,
IT refers to any value found after the label
of the corresponding leaf-sexp in 'object'.
Outside of an ANY leaf-sexp in a rule, IT is meaningless.
  So for instance:
    object = (a (b c))
    rule = (a (b (ANY x IT y)))
    output = (x:c:y)
  Note that a single IT can match multiple values:
    object = (a (b c d))
    rule = (a (b (ANY x IT y)))
    output = (x:c:y x:d:y)
.
RED, GREEN, and BLUE are color keywords that can appear
as the first element of any rule list, before the label.
They set the color for all output generated by that rule
and any nested rules, unless overridden by a deeper color keyword.
The color is applied as a text property to the output strings.
  For example, if
    rule = (a (RED b (c d) (GREEN e f))),
    then any 'd' produced by the rule will be red,
    but any 'f' produced by the rule will be green.
.
A leaf-list in a rule can be vacuous, a singleton label.
This is just to demonstrate that the possibility has been considered,
and does not affect the output.
Such singleton leaf-lists can be omitted from the rule to no effect."
  (if
      (or
        (not (listp object))
        (not (listp rules))
        (not (equal (car object) (skg--extract-label rules))))
      '()
    (skg--transform-sexp-flat-from object rules nil)))

(defun skg--color-keyword-p
  (sym)
  "Return t if SYM is a color keyword (RED, GREEN, or BLUE)."
  (memq sym '(RED GREEN BLUE)))

(defun skg--extract-color
  (rule)
  "Extract color keyword from RULE if present, else return nil."
  (when
    (and
      (listp rule)
      (skg--color-keyword-p (car rule)))
    (car rule)))

(defun skg--extract-label
  (rule)
  "Extract label from RULE, skipping color keyword if present."
  (if
    (and
      (listp rule)
      (skg--color-keyword-p (car rule)))
    (cadr rule)
    (car rule)))

(defun skg--rule-children
  (rule)
  "Get children of RULE, skipping color keyword and label."
  (if
    (and
      (listp rule)
      (skg--color-keyword-p (car rule)))
    (cddr rule)
    (cdr rule)))

(defun skg--transform-sexp-flat-from
  (object
    rule
    current-color)
  "Transform OBJECT using RULE with CURRENT-COLOR context."
  (let
      ((new-color
         (or (skg--extract-color rule) current-color))
        (results '()))
    (dolist
        (rule-child (skg--rule-children rule))
      (setq results
            (nconc results
                   (skg--transform-sexp-flat-dispatch
                    object rule-child new-color))))
    results))

(defun skg--transform-sexp-flat-dispatch
  (object
    rule-child
    current-color)
  "Dispatch RULE-CHILD application to OBJECT with CURRENT-COLOR."
  (cond
    ((not (listp rule-child)) '())
    ((skg--rule-any-leaf-p rule-child)
      (skg--apply-any-leaf object rule-child current-color))
    ((skg--rule-leaf-p rule-child)
      (skg--apply-ordinary-leaf object rule-child current-color))
    (t
      (skg--apply-non-leaf object rule-child current-color))))

(defun skg--rule-leaf-p
  (rule-child)
  "Return t if RULE-CHILD is a leaf rule (no sublists after label)."
  (let
      ((children (skg--rule-children rule-child)))
    (not
      (cl-some #'listp children))))

(defun skg--rule-any-leaf-p
  (rule-child)
  "Return t if RULE-CHILD is an ANY leaf rule."
  (and
    (eq (skg--extract-label rule-child) 'ANY)
    (skg--rule-leaf-p rule-child)))

(defun skg--apply-non-leaf
  (object
    rule-child
    current-color)
  "Apply non-leaf RULE-CHILD to OBJECT with CURRENT-COLOR."
  (let
      ((matches
          (skg--object-children-with-label
            object (skg--extract-label rule-child)))
        (results '()))
    (dolist
        (match matches)
      (setq results
            (nconc results
                   (skg--transform-sexp-flat-from
                    match rule-child current-color))))
    results))

(defun skg--apply-ordinary-leaf
  (object
    rule-child
    current-color)
  "Apply ordinary leaf RULE-CHILD to OBJECT with CURRENT-COLOR."
  (let
      ((color
         (or (skg--extract-color rule-child) current-color))
        (label (skg--extract-label rule-child))
        (tokens (skg--rule-children rule-child))
        (matches
          (skg--object-atomic-matches
            object (skg--extract-label rule-child)))
        (results '()))
    (when tokens
      (dolist
          (_ matches)
        (setq results
              (nconc results
                      (list (skg--tokens->string tokens color))))))
    results))

(defun skg--apply-any-leaf
  (object
    rule-child
    current-color)
  "Apply ANY leaf RULE-CHILD to OBJECT with CURRENT-COLOR."
  (let
      ((color
         (or (skg--extract-color rule-child) current-color))
        (tokens (skg--rule-children rule-child))
        (tail-values (cdr object))
        (results '()))
    (cond
      ((null tokens) '())
      ((memq 'IT tokens)
        (dolist
            (tail-value tail-values)
          (setq results
                (nconc results
                        (list
                          (skg--tokens->string
                            (skg--replace-it tokens tail-value)
                            color)))))
        results)
      (t
        (list (skg--tokens->string tokens color))))))

(defun skg--replace-it
  (tokens
    tail-value)
  (mapcar
    (lambda
      (token)
      (if
          (eq token 'IT)
          tail-value
        token))
    tokens))

(defun skg--object-children-with-label
  (object
    label)
  (cl-loop
    for element in (cdr object)
    when
    (and
      (listp element)
      (equal (car element) label))
    collect element))

(defun skg--object-atomic-matches
  (object
    label)
  (cl-loop
    for element in (cdr object)
    when
    (and
      (not (listp element))
      (equal element label))
    collect element))

(defun skg--tokens->string
  (tokens
    current-color)
  "Convert TOKENS to a propertized string with CURRENT-COLOR.
Returns a string with text properties for color rendering."
  (let
      ((str
         (mapconcat #'skg--token->string tokens ":")))
    (when current-color
      (put-text-property 0 (length str) 'skg-color current-color str))
    str))

(defun skg--token->string
  (token)
  "Convert TOKEN to string representation."
  (cond
    ((symbolp token) (symbol-name token))
    ((stringp token) token)
    (t (format "%s" token))))

(provide 'skg-lens)
