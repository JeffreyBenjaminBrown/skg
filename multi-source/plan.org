#+title: Multi-Source Data Integration - Implementation Plan
#+date: 2025-11-11

* Overview

This document outlines the plan for refactoring Skg to support multiple data sources instead of a single =skg_folder=. Each source will have a path, nickname, and ownership flag.

* Current State (After Phase 3)

** Configuration
=skgconfig.toml= now uses =[[sources]]= array format:
- Each source has: nickname, path, user_owns_it
- Deserialized into =HashMap<String, SkgfileSource>= in SkgConfig
- Location: =rust/types/misc.rs=

** File Loading ✓ IMPLEMENTED
At startup (=rust/init.rs:29-36=):
1. =read_all_skg_files_from_sources()= scans all configured source directories
2. Each file is parsed into a =SkgNode= with source field set to source nickname
3. Duplicate IDs across sources are detected and rejected
4. All nodes are loaded into TypeDB and Tantivy

** Path Generation (Still using "main" - Phase 5)
=path_from_pid()= (=rust/util.rs:17-27=) dynamically constructs file paths:
- Currently hardcoded to use "main" source (temporary)
- Takes =config= and =pid= (primary ID)
- Returns: =main_source.path / pid.skg=
- TODO: Accept source parameter and use node's source field

** Saving (Still using "main" - Phase 5)
When saving (=rust/save.rs=, =rust/media/file_io/multiple_nodes.rs=):
- All .skg files are written to "main" source only (temporary)
- Filename is determined by primary ID
- TODO: Write to appropriate source based on node.source field

* Target State

** Configuration Structure
Replace =skg_folder: PathBuf= with a map of sources.

Configuration will use =HashMap<String, SkgfileSource>= where:
- Key: nickname (String)
- Value: SkgfileSource struct

Each =SkgfileSource= has:
- =path: PathBuf= - directory containing .skg files
- =nickname: String= - unique identifier (duplicated as map key for convenience)
- =user_owns_it: bool= - whether user can modify nodes from this source

TOML format (array of tables):
#+begin_src toml
[[sources]]
nickname = "main"
path = "data/skg"
user_owns_it = true

[[sources]]
nickname = "shared"
path = "data/shared-skg"
user_owns_it = false
#+end_src

Note: Serde can deserialize =[[sources]]= array into a HashMap by using nickname as key.

** SkgNode Changes
Add =source: String= field:
- Position: after =aliases=, before =ids=
- Mandatory field
- NOT serialized to .skg files (inferred from file location)

** TypeDB Schema Changes
Add to =schema.tql= (after =attribute id=):
#+begin_src tql
attribute source, value string;
#+end_src

Every =node= entity must own this attribute:
#+begin_src tql
entity node,
  owns id @key,
  owns source,
  ...
#+end_src

** OrgNodeMetadata Changes
Add =source: Option<String>= field after =id= (=rust/types/orgnode.rs:16-20=).

Represented in s-expression as: =(source nickname)=

Similar to =(id abc123)=.

** Save Logic Changes
*** Source Inheritance
When processing orgnodes for save:
- If orgnode has no associated source, inherit from parent
- Source determines target directory for writing .skg file
- Users can only create nodes as roots (which must have explicit source) or as children (which inherit)

*** Validation
Before saving, validate that all root nodes have a source.

Add new error variant to =BufferValidationError=:
#+begin_src rust
RootWithoutSource (OrgNode)
#+end_src

Location: =rust/types/errors.rs:5-33=

*** Foreign Data Handling
Foreign data (where =user_owns_it = false=) has special semantics:

**** What Users CAN Do
- View foreign nodes (included in content views)
- Create links to foreign nodes
- Subscribe to foreign nodes
- Include foreign nodes in saved buffers (if unmodified)

**** What Users CANNOT Do
- Modify title, body, or contents of foreign nodes
- Delete foreign nodes
- Create new nodes in foreign sources

**** Save Validation for Foreign Data
When saving a buffer containing foreign nodes:
1. Extract =SkgNode= from the =OrgNode= (as normal)
2. Read corresponding =SkgNode= from disk
3. Compare: =title=, =body=, and =contains= fields
4. If identical: allow save (skip writing this node)
5. If different: reject save with error

**Exception for indefinitive nodes:**
- Indefinitive orgnodes from foreign sources are allowed in buffers
- They do NOT append content to the foreign node
- Treated as read-only views, even if marked indefinitive

* Required Code Changes

** 1. Configuration (=rust/types/misc.rs=)

*** Define SkgfileSource struct
#+begin_src rust
#[derive(Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]
pub struct SkgfileSource {
  pub nickname: String,      // Duplicated as map key for convenience
  pub path: PathBuf,
  pub user_owns_it: bool,
}
#+end_src

*** Modify SkgConfig
Replace:
#+begin_src rust
pub skg_folder: PathBuf,
#+end_src

With:
#+begin_src rust
pub sources: HashMap<String, SkgfileSource>,
#+end_src

*** Custom Deserialization
Need custom deserialize to convert =[[sources]]= TOML array into HashMap:
#+begin_src rust
// In SkgConfig, use:
#[serde(deserialize_with = "deserialize_sources")]
pub sources: HashMap<String, SkgfileSource>,

fn deserialize_sources<'de, D>(
  deserializer: D
) -> Result<HashMap<String, SkgfileSource>, D::Error>
where D: Deserializer<'de>
{
  let sources_vec: Vec<SkgfileSource> = Vec::deserialize(deserializer)?;
  let mut map = HashMap::new();
  for source in sources_vec {
    map.insert(source.nickname.clone(), source);
  }
  Ok(map)
}
#+end_src

*** Add helper methods
- =get_source(&self, nickname: &str) -> Option<&SkgfileSource>=
- =get_source_path(&self, nickname: &str) -> Option<&PathBuf>=
- =user_owns_source(&self, nickname: &str) -> bool=

** 2. SkgNode Type (=rust/types/skgnode.rs=)

Add field after =aliases=:
#+begin_src rust
pub source: String,

#[serde(skip_serializing, skip_deserializing)]
#+end_src

Note: Use =serde(skip)= to prevent writing to .skg files.

** 3. TypeDB Schema (=schema.tql=)

Add after line 4:
#+begin_src tql
attribute source, value string;
#+end_src

Modify =entity node= (after line 42):
#+begin_src tql
entity node,
  owns id @key,
  owns source,
  ...
#+end_src

** 4. OrgNodeMetadata (=rust/types/orgnode.rs=)

Add field after =id=:
#+begin_src rust
pub source: Option<String>,
#+end_src

** 5. Metadata Serialization (=rust/serve/parse_headline_md_sexp.rs=)

*** In =orgnodemd_to_string= (lines 39-116)
After the =id= serialization (line 45-46), add:
#+begin_src rust
if let Some(ref source) = metadata.source {
  parts.push(format!("(source {})", source));
}
#+end_src

*** In =parse_metadata_to_orgnodemd= (lines 190-235)
Add pattern matching for ="source"= (similar to ="id"= at lines 220-225):
#+begin_src rust
"source" => {
  if items.len() != 2 {
    return Err("source requires exactly one value".to_string());
  }
  let value: String = atom_to_string(&items[1])?;
  result.source = Some(value);
},
#+end_src

** 6. File Loading (=rust/media/file_io/multiple_nodes.rs=) ✓ COMPLETED

Created new public function (Phase 3):
#+begin_src rust
pub fn read_all_skg_files_from_sources(
  sources: &HashMap<String, SkgfileSource>
) -> io::Result<Vec<SkgNode>>
#+end_src

Helper function (private):
#+begin_src rust
fn read_skg_files<P: AsRef<Path>>(dir_path: P) -> io::Result<Vec<SkgNode>>
#+end_src

Implementation:
1. ✓ Call private =read_skg_files(source.path)= for each source
2. ✓ Set =source= field on each returned =SkgNode= to =source.nickname=
3. ✓ Accumulate all nodes from all sources
4. ✓ Check for duplicate IDs across sources (fail fast if found)
5. ✓ Track all IDs using HashMap<String, Vec<String>> (ID -> source nicknames)
6. ✓ Made =read_skg_files= private (Phase 3b cleanup)
7. ✓ Updated all test code to use =read_all_skg_files_from_sources= (Phase 3b cleanup)

** 7. Initialization (=rust/init.rs=) ✓ COMPLETED

Modified =initialize_dbs= (Phase 3):
- ✓ Replaced =read_skg_files(skg_folder_str)=
- ✓ With =read_all_skg_files_from_sources(&config.sources)=
- ✓ Updated print messages to show multiple sources
- ✓ Removed temporary "main" source hardcoding

** 8. Path Generation (=rust/util.rs=)

Modify =path_from_pid= signature (lines 13-23):
#+begin_src rust
pub fn path_from_pid(
  config: &SkgConfig,
  source: &str,  // Add this parameter
  pid: ID,
) -> String
#+end_src

Implementation:
1. Look up source by nickname in =config.sources=
2. Use =source.path= instead of =config.skg_folder=
3. Join with =pid.skg=

** 9. TypeDB Node Creation (=rust/media/typedb/nodes.rs=)

Modify =create_node= (lines 121-140):
- Add =source= attribute to the insert query
- Use =node.source= value

** 10. Validation (=rust/types/errors.rs=)

Add variant to =BufferValidationError=:
#+begin_src rust
RootWithoutSource (OrgNode),
#+end_src

** 11. Buffer Validation (=rust/save/buffer_to_orgnodes/validate_tree.rs=)

Add validation in =find_buffer_errors_for_saving= (lines 18-129):

After line 46, add:
#+begin_src rust
let root_errors = validate_roots_have_sources(trees);
errors.extend(root_errors);
#+end_src

Create new function:
#+begin_src rust
fn validate_roots_have_sources(
  trees: &[Tree<OrgNode>]
) -> Vec<BufferValidationError> {
  let mut errors = Vec::new();
  for tree in trees {
    let root = tree.root().value();
    if root.metadata.source.is_none() {
      errors.push(BufferValidationError::RootWithoutSource(root.clone()));
    }
  }
  errors
}
#+end_src

** 12. Source Inheritance During Save

Modify =add_missing_info_dfs= in =rust/save/buffer_to_orgnodes/add_missing_info.rs= (lines 48-78):

Pass parent's source down to children:
#+begin_src rust
fn add_missing_info_dfs(
  mut node_ref: ego_tree::NodeMut<OrgNode>,
  parent_treatment: Option<RelToParent>,
  parent_source: Option<String>,  // Add this
)
#+end_src

Add function:
#+begin_src rust
fn inherit_source_if_needed(
  node: &mut OrgNode,
  parent_source: Option<String>
) {
  if node.metadata.source.is_none() {
    node.metadata.source = parent_source;
  }
}
#+end_src

Call this before processing children.

** 13. File Writing

Modify =write_all_nodes_to_fs= in =rust/media/file_io/multiple_nodes.rs= (lines 32-54):

Change signature:
#+begin_src rust
pub fn write_all_nodes_to_fs(
  nodes: Vec<SkgNode>,
  config: &SkgConfig,  // Change to reference
) -> io::Result<usize>
#+end_src

For each node:
1. Look up source directory using =node.source= and =config=
2. Create directory if needed
3. Write to =source_path / pid.skg=

** 14. Error Display (=rust/types/errors.rs=)

Update =impl Display for BufferValidationError= to handle =RootWithoutSource=.

** 15. SkgNode Creation from OrgNode

Modify =mk_skgnode= in =rust/save/orgnodes_to_instructions/to_dirty_instructions.rs= (lines 51-73):

Add source field:
#+begin_src rust
source: orgnode.metadata.source.clone()
  .ok_or_else(|| "SkgNode missing source".to_string())?,
#+end_src

** 16. Source Reconciliation for Duplicate Instructions

When multiple orgnodes have the same ID (after ID replacement with PID), determine the canonical source to use.

Location: =rust/save/orgnodes_to_instructions/reconcile_dup_instructions.rs=

Add function:
#+begin_src rust
fn reconciled_source(
  indefinitives: &[SaveInstruction],
  definer: Option<&SaveInstruction>,
) -> Result<String, Box<dyn Error>> {
  // Priority: definer's source > first indefinitive's source
  if let Some((node, _)) = definer {
    return Ok(node.source.clone());
  }
  if !indefinitives.is_empty() {
    return Ok(indefinitives[0].0.source.clone());
  }
  Err("No source found in buffer orgnodes for reconciliation".into())
}
#+end_src

Call this in =reconcile_dup_instructions_for_one_id= before reading from disk:
- Compute reconciled source from buffer orgnodes (definer takes priority)
- Use reconciled source to determine which .skg file to read
- Include reconciled source in the merged result

** 17. Foreign Data Validation During Save

Add new error type to =rust/types/errors.rs=:
#+begin_src rust
ModifiedForeignNode(ID, String),  // (node_id, source_nickname)
#+end_src

Create new validation function in =rust/save/validate_foreign_nodes.rs=:
#+begin_src rust
pub fn validate_foreign_nodes(
  instructions: &[SaveInstruction],
  config: &SkgConfig,
) -> Result<Vec<SaveInstruction>, Vec<BufferValidationError>> {
  // For each instruction:
  // 1. Check if node.source is foreign (user_owns_it = false)
  // 2. If foreign and NOT indefinitive:
  //    a. Read corresponding SkgNode from disk
  //    b. Compare title, body, contains
  //    c. If different: add ModifiedForeignNode error
  //    d. If same: filter out from write instructions
  // 3. If foreign and indefinitive:
  //    - Filter out from write instructions (no append)
  // Return filtered instructions or errors
}
#+end_src

Call this in =rust/save.rs= after instruction generation, before filesystem/TypeDB updates.

** 18. Source Path Validation

In =rust/media/file_io/misc.rs=, add:
#+begin_src rust
pub fn validate_source_paths_creating_owned_ones_if_needed(
  sources: &HashMap<String, SkgfileSource>
) -> io::Result<()> {
  for (nickname, source) in sources.iter() {
    if !source.path.exists() {
      if source.user_owns_it {
        // Create directory for owned sources
        fs::create_dir_all(&source.path)?;
        eprintln!("Created directory for source '{}': {:?}",
                  nickname, source.path);
      } else {
        // Fail for foreign sources
        return Err(io::Error::new(
          io::ErrorKind::NotFound,
          format!("Foreign source '{}' path does not exist: {:?}",
                  nickname, source.path)));
      }
    }
  }
  Ok(())
}
#+end_src

Call this immediately after loading config in =load_config=.

** 19. Config Migration Script

Create =scripts/migrate-configs.sh= to update all skgconfig.toml files:
#+begin_src bash
#!/bin/bash
# Find all skgconfig.toml files and convert them

find . -name "skgconfig.toml" -type f | while read config_file; do
  echo "Migrating $config_file"
  # Read old skg_folder value
  # Generate new [[sources]] format with nickname="main"
  # Rewrite file
done
#+end_src

Or implement in Rust as a one-time utility program.

* Resolved Design Decisions

These decisions have been finalized based on stakeholder input:

** 1. Type Names and Structure
- Source type named =SkgfileSource= (not DataSource)
- Config uses =HashMap<String, SkgfileSource>= (not Vec)
- Nickname stored both as map key and in struct for convenience

** 2. Configuration Format: Array of Tables
Use TOML =[[sources]]= array syntax:
#+begin_src toml
[[sources]]
nickname = "main"
path = "data/skg"
user_owns_it = true
#+end_src

Requires custom deserializer to convert array into HashMap keyed by nickname.

** 3. Duplicate IDs: Fail Fast
If the same ID exists in multiple sources, fail during load with clear error.
Preserves ID uniqueness invariant enforced by TypeDB.

** 4. Default Source: Not an Issue
- Root nodes MUST have explicit source (validation error otherwise)
- Non-root nodes inherit from parent
- No need for "default" source concept

** 5. Source Path Validation
Validate during config load:
- If path doesn't exist and =user_owns_it = true=: create directory
- If path doesn't exist and =user_owns_it = false=: fail with error
- Prevents runtime surprises

** 6. user_owns_it Semantics
*** What users CAN do with foreign sources (=user_owns_it = false=):
- View nodes (build content views)
- Create links to nodes
- Subscribe to nodes
- Include unmodified foreign nodes in saved buffers

*** What users CANNOT do:
- Modify title, body, or contents of foreign nodes
- Delete foreign nodes
- Create new nodes in foreign sources

*** Save validation:
- Compare OrgNode-derived SkgNode with disk version
- If title, body, or contains differ: reject save
- If identical: allow (but skip writing)
- Indefinitive foreign nodes: allowed in buffer but don't append content

** 7. Migration Strategy: No Backward Compatibility
- Breaking change: =skg_folder= field removed entirely
- All existing config files must be updated
- Use script or manual process to migrate configs
- Application is not in production yet, so acceptable

** 8. TypeDB and Tantivy Updates
- TypeDB: Add =source= attribute to all nodes
- Tantivy: Add =source= field to indexed documents
- Queries: Source-agnostic initially, can add filters later

** 9. File Format Clarification
- .skg files: YAML format (unchanged)
- config files: TOML format (unchanged)
- =source= field: NOT in .skg files (inferred from file path)

** 10. API Changes: None Required
TCP API endpoints work transparently with source metadata.
Future enhancement: add "list sources" endpoint.

** 11. Root Node Definition: Tree Forest Roots
Roots are top-level nodes in =Vec<Tree<OrgNode>>= (no org-parent).
Check =tree.root().value()= for each tree.

** 12. Source Changes: Deferred
Moving nodes between sources is a future enhancement.
Initially, source is immutable after creation.

** 13. Error Types
- =RootWithoutSource(OrgNode)= - root missing source metadata
- =ModifiedForeignNode(ID, String)= - attempted modification of foreign data

** 14. Test Data Updates
- Update all on-disk config files to new format (via script or direct edit)
- Generate in-RAM configs using test helper function
- Minimal disruption: most tests use single source

* Implementation Order

** Phase 1: Core Data Structures and Config Migration [COMPLETED]
1. ✓ Added =SkgfileSource= struct to =rust/types/misc.rs=
2. ✓ Added =sources: HashMap<String, SkgfileSource>= to =SkgConfig= with custom deserializer
3. ✓ Migrated all config files manually (2 files updated)
4. ✓ Removed =skg_folder= field from =SkgConfig= (removed Hash derive too)
5. ✓ Added helper methods to SkgConfig (=get_source=, =get_source_path=, =user_owns_source=)
6. ✓ Added =source: String= field to =SkgNode= (went straight to mandatory - Phase 9 done early)
7. ✓ Added =source: Option<String>= field to =OrgnodeMetadata=
8. ✓ Updated TypeDB schema with =source= attribute
9. ✓ Fixed all compilation errors (11 locations with temporary "main" workarounds)
10. ✓ Updated test helper to generate configs with HashMap
11. ✓ Implemented =reconciled_source()= function for duplicate instruction handling

Notes:
- Phase 9 (Make Source Mandatory) was completed during Phase 1
- Source set to "main" after all file reads (11 locations) - see temporary-changes.org
- Removed Hash derive from SkgConfig (HashMap doesn't implement Hash)
- Source reconciliation logic prioritizes definer over indefinitives

** Phase 2: Source Path Validation [COMPLETED]
1. ✓ Implemented =validate_source_paths_creating_owned_ones_if_needed= in =rust/media/file_io/misc.rs=
2. ✓ Called from =load_config= immediately after parsing
3. ✓ Added 6 comprehensive tests in =tests/source_path_validation.rs=

Tests cover:
- Existing owned sources (pass)
- Nonexistent owned sources (create directory and pass)
- Existing foreign sources (pass)
- Nonexistent foreign sources (fail with NotFound error)
- Multiple sources with mixed ownership
- Multiple sources where one foreign source fails

Notes:
- Function creates directories for owned sources that don't exist
- Function fails with clear error for missing foreign sources
- All 115 tests passing

** Phase 3: File Loading with Sources [COMPLETED including Phase 3b]
1. ✓ Implemented =read_all_skg_files_from_sources= with HashMap parameter
2. ✓ Added duplicate ID detection across sources with clear error messages
3. ✓ Updated =initialize_dbs= to use new loading function
4. ✓ Added 8 comprehensive tests in =tests/multi_source_loading.rs=
5. ✓ Tests create temporary source directories as fixtures

Initial tests (Phase 3):
- Loading from single source
- Loading from multiple sources with correct source field assignment
- Duplicate ID detection across sources (fails with InvalidData error)
- Duplicate detection for nodes with multiple IDs
- Handling empty sources
- Verifying source field is set correctly for each node

Phase 3b enhancements:
- ✓ Changed to collect ALL duplicate IDs instead of failing on first
- ✓ Changed to collect ALL file read errors instead of failing on first
- ✓ Implemented org file output for >10 duplicates (=initialization-error_duplicate-ids.org=)
- ✓ Implemented org file output for unreadable files (=initialization-error_unreadable-skg-files.org=)
- ✓ Sorted error output: IDs alphabetically, sources alphabetically, paths alphabetically
- ✓ Enhanced tests to verify complete org file content with exact string comparison
- ✓ Added test: =test_many_duplicate_ids_creates_org_file= (verifies org file with 15 duplicates)
- ✓ Added test: =test_unreadable_files_creates_org_file= (verifies org file for bad source)
- ✓ Made =read_skg_files= private (cleanup)
- ✓ Updated all test code to use =read_all_skg_files_from_sources= (cleanup)
- ✓ Removed misleading TODO comment in =read_skg_files= (cleanup)

Implementation notes:
- Function iterates over all sources in HashMap
- Sets =node.source= to the correct nickname for each loaded node
- Tracks all IDs seen across sources using =HashMap<String, Vec<String>>=
- Continues loading even after errors, collecting all issues
- Reports to stderr for ≤10 duplicates, writes org file for >10
- Always writes org file for unreadable files
- Sorted output enables deterministic testing and easier user review
- Tests generate expected content programmatically and do exact comparison
- Error message includes specific IDs for small numbers of duplicates
- Removed temporary "main" hardcoding from =rust/init.rs=

All 123 tests passing

** Phase 4: Metadata Serialization and Parsing [COMPLETED]
1. ✓ Updated =orgnodemd_to_string= to serialize source (lines 46-47)
2. ✓ Updated =parse_orgnode_metadata_sexp= to parse source (lines 226-231)
3. ✓ Added tests - updated 5 test files to include =(source main)= in org-mode data
4. ✓ Updated =mk_skgnode= to require source in orgnode metadata (error if missing)
5. ✓ Simplified =reconciled_source()= to work with mandatory String (no Option handling)

Notes:
- Source rendered as =(source nickname)= in org-mode format
- Source parsed between =id= and =view= sections
- Format matches existing =(id ...)= pattern
- =reconciled_source()= implementation simplified after source made mandatory

** Phase 5: Path Generation and File Writing
1. Update =path_from_pid= signature to accept source parameter
2. Find and update all call sites of =path_from_pid=
3. Modify =write_all_nodes_to_fs= to use source-specific paths
4. Test writing to multiple source directories
** Phase 6: Source Inheritance During Save
1. Modify =add_missing_info_dfs= to accept and pass parent source
2. Implement =inherit_source_if_needed= helper
3. Update recursive calls to pass source down tree
4. Add tests for source inheritance from parent to children

** Phase 7: Validation and Error Handling
Note: This phase happens AFTER Phase 6 source inheritance, so all orgnodes have sources.

1. Add source consistency validation:
   - Implement =validate_source_consistency= helper function
   - After source inheritance in Phase 6, group orgnodes by ID
   - Check that all orgnodes with same ID have identical source values
   - Add =InconsistentSources(ID, Vec<String>)= to =BufferValidationError=
   - Integrate into =find_buffer_errors_for_saving=
   - Add tests for inconsistent source detection
2. Add =RootWithoutSource(OrgNode)= to =BufferValidationError=
3. Add =ModifiedForeignNode(ID, String)= to =BufferValidationError=
4. Implement =validate_roots_have_sources=
5. Integrate root validation into =find_buffer_errors_for_saving=
6. Update =impl Display for BufferValidationError=
7. Add tests for root validation

** Phase 8: Foreign Data Validation
1. Create =rust/save/validate_foreign_nodes.rs= module
2. Implement =validate_foreign_nodes= function
3. Integrate into save pipeline in =rust/save.rs=
4. Add tests for:
   - Unmodified foreign nodes (allowed)
   - Modified foreign nodes (rejected)
   - Indefinitive foreign nodes (filtered, no append)
   - Owned nodes (unchanged behavior)

** Phase 9: Make Source Mandatory [COMPLETED]
1. ✓ Changed =SkgNode.source= from =Option<String>= to =String=
2. ✓ Updated =mk_skgnode= to require source (error if missing)
3. ✓ Fixed all compilation errors
4. ✓ Updated all test fixtures to include sources (44+ locations)
5. ✓ All 108 tests passing

Notes:
- Added source setting after every =read_node()= call (11 locations) - currently hardcoded to "main" with TODO comments
- =OrgnodeMetadata.source= remains =Option<String>= (correct for user input)
- Simplified =reconciled_source()= - no longer needs Option handling
- Added support for source field in org-mode metadata parsing and rendering


** Phase 10: TypeDB and Tantivy Integration
1. Update =create_node= in TypeDB to include source attribute
2. Update =create_all_nodes= calls
3. Add source field to Tantivy schema
4. Update =update_index_with_nodes= to index source
5. Test database initialization with sources

** Phase 11: Polish and Documentation
1. Add source field to all error messages where relevant
2. Update OVERVIEW.org with multi-source model
3. Update api-and-formats.md if needed
4. Add comments explaining foreign data validation
5. Performance testing with multiple sources
6. Consider adding "list sources" API endpoint (optional)

* Testing Strategy

** Unit Tests
- ✓ Config parsing with multiple sources and HashMap structure
- ✓ Custom deserializer for =[[sources]]= array to HashMap
- ✓ Duplicate ID detection across sources (Phase 3)
- Source inheritance logic (parent to child) - Phase 6
- Path generation with source parameter - Phase 5
- Validation of roots without sources - Phase 7
- Foreign node validation - Phase 8:
  - Unmodified foreign nodes (pass)
  - Modified foreign nodes (fail)
  - Indefinitive foreign nodes (filter)
- ✓ Source path validation (create owned, fail foreign) (Phase 2)

** Integration Tests
- ✓ Load from multiple source directories simultaneously (Phase 3)
- Save to different sources based on node source field - Phase 5
- Mixed ownership scenarios (=user_owns_it=) - Phase 8
- Foreign data in views (viewable but not modifiable) - Phase 8
- Attempting to modify foreign data (should error) - Phase 8
- Source inheritance through multi-level trees - Phase 6
- ✓ Config migration (verify all configs updated correctly) (Phase 1)

** Test Fixtures Needed
1. Multi-source config.toml files with =[[sources]]= format
2. Directory structure with multiple source folders:
   - data/skg-owned (user_owns_it=true)
   - data/skg-foreign (user_owns_it=false)
3. .skg files in each source directory
4. Nodes with source metadata in org format: =(skg (id _) (source nickname))=
5. Read-only source scenarios with foreign data
6. Test helper for generating HashMap-based configs

* Risk Assessment

** High Risk
- **Breaking change to config format**: No backward compatibility, all configs must be updated
  - *Mitigation*: Migration script/process to update all configs before code changes
  - *Impact*: Application not in production, acceptable
- **TypeDB schema change**: Requires database rebuild, impacts existing data
  - *Mitigation*: Database is rebuilt from .skg files on each startup
  - *Impact*: No persistent TypeDB data loss concern
- **Source field is mandatory**: All code paths must set it correctly
  - *Mitigation*: Compiler will catch missing source assignments
  - *Impact*: Start with Option<String>, transition to String after validation working

** Medium Risk
- **Foreign data validation complexity**: Must compare OrgNode-derived vs disk SkgNodes
  - *Mitigation*: Isolated in single module, well-tested
  - *Impact*: Complex logic but contained
- **HashMap custom deserializer**: TOML array to HashMap conversion
  - *Mitigation*: Standard Serde pattern, test thoroughly
  - *Impact*: If broken, config parsing fails immediately (fail fast)
- **Path construction changes**: Many call sites to update for =path_from_pid=
  - *Mitigation*: Compiler will find all call sites
  - *Impact*: Mechanical refactoring, straightforward
- **Test fixture updates**: Time-consuming but straightforward
  - *Mitigation*: Update incrementally, phase by phase
  - *Impact*: Test failures will be obvious

** Low Risk
- **Metadata serialization**: Well-contained in one module
- **Validation additions**: Incremental to existing validation
- **Source path validation**: Simple directory check/create logic
- **Duplicate ID detection**: O(n) HashSet check, straightforward

* Success Criteria

Core Functionality:
- [X] Can load .skg files from multiple directories simultaneously
- [X] Each node tracks its source (mandatory field)
- [X] Source appears in org-mode metadata as =(source nickname)=
- [ ] Nodes inherit source from parent during save
- [ ] Root nodes without source are rejected with clear error
- [ ] Files are written to correct source directory based on node.source

Foreign Data Handling:
- [ ] Foreign nodes can be viewed in content views
- [ ] Unmodified foreign nodes can be included in saved buffers
- [ ] Modified foreign nodes trigger save errors
- [ ] Indefinitive foreign nodes don't append content
- [ ] Cannot create new nodes in foreign sources

Data Integrity:
- [ ] TypeDB stores source attribute for all nodes
- [ ] Tantivy indexes source for all documents
- [X] Duplicate IDs across sources detected and rejected
- [X] Source paths validated at startup

Error Reporting:
- [X] Comprehensive error collection (all duplicates, all file errors)
- [X] Sorted error output for deterministic reporting
- [X] Org file generation for large numbers of errors (>10 duplicates)
- [X] Org file generation for unreadable files
- [X] Tests verify complete error report content

Testing and Migration:
- [X] All existing tests pass with updated fixtures (123 tests)
- [X] All config files migrated to new format
- [X] Test helper generates HashMap-based configs
- [X] Multi-source integration tests pass

Documentation:
- [ ] OVERVIEW.org updated with multi-source model
- [X] Plan document captures all design decisions (including Phase 3b)
- [X] Surprises document tracks all implementation discoveries
- [X] Temporary changes document tracks workarounds and resolution plan
- [ ] Code comments explain foreign data validation (Phase 8)
- [X] Error messages include source information where relevant

* Lessons Learned from Phases 1-3b

This section captures insights and patterns discovered during implementation that may inform future phases.

** Pattern: Source must be set immediately after deserialization

Since =SkgNode.source= is not serialized to .skg files, it must be set immediately after every =read_node()= call. Missing this causes type errors (mandatory field).

Lesson: Any function that reads a node from disk must either:
1. Set the source field before returning, or
2. Be called by a wrapper that sets the source

The =read_all_skg_files_from_sources= pattern (wrapper sets source) works well.

** Pattern: Duplicate detection requires HashMap for O(1) lookup

Initial consideration was to check for duplicates with nested loops (O(n²)). Using =HashMap<String, String>= for tracking ID→source mappings provides O(1) lookup per ID.

With N nodes and M IDs per node average: O(N*M) total time, which is efficient.

** Pattern: Comprehensive error collection improves user experience (Phase 3b)

Initial implementation (Phase 3) used fail-fast error handling: return error on first problem found (duplicate ID, missing file). This simplified implementation but created poor user experience.

Phase 3b enhancement: Changed to collect ALL errors before reporting:
- Continue scanning all sources even after finding problems
- Collect all duplicate IDs and file read errors
- Report comprehensively: stderr for small numbers, org files for large batches
- Users can fix all problems at once instead of iteratively

Trade-off: More complex implementation, but much better user experience for large repositories with multiple sources.

** Pattern: TODO comments track temporary workarounds effectively

Marking temporary code with "TODO Phase X:" comments made it easy to:
- Track what needs fixing later
- Understand why code is written a certain way
- Find all related workarounds using grep

Recommendation: Continue this pattern for remaining phases.

** Integration point: TypeDB and Tantivy already handle source field

TypeDB schema includes =source= attribute. When Phase 3 loaded nodes with source field set, both databases handled it correctly. No changes needed to =create_all_nodes= or =update_index_with_nodes= yet (they just pass through the field).

Phase 10 will explicitly add source indexing, but basic functionality already works.

** Pattern: Sorted output improves testing and debugging (Phase 3b enhancement)

Making error reports deterministic by sorting before output:
- Org file output is now sorted (IDs alphabetically, sources alphabetically)
- Enables full programmatic comparison in tests vs substring checks
- Tests generate expected content and do exact string comparison
- Easier for users to review and compare error reports
- Simpler test code: no need to parse structure, just build expected and compare

Implementation: Sort HashMap keys into Vec, then iterate sorted collection.

Trade-off: Tiny performance cost (negligible for error reporting) for major testing and UX benefits.

** Pattern: Make helpers private once API stabilizes (Phase 3b cleanup)

After Phase 3 implementation stabilized, made =read_skg_files= private:
- It's only used internally by =read_all_skg_files_from_sources=
- Cleaner public API: users only see the multi-source version
- Updated all test code to use the public API (with single-source HashMap)
- Maintains good separation of concerns (directory reading vs multi-source orchestration)

Benefits: Simpler API surface, prevents misuse, all code paths now go through multi-source logic.

* Resolved Questions

** 1. Source iteration order during loading ✓ RESOLVED

HashMap iteration order is non-deterministic in Rust, but this doesn't matter for our use case.

Decision: Keep non-deterministic iteration order for loading, but sort for error reporting
Rationale:
- Loading order doesn't affect correctness
- All nodes are loaded before relationships are created (TypeDB constraint)
- For error reporting: sort output alphabetically for determinism (Phase 3b enhancement)
- Sorted errors improve testing and user experience

** 2. Duplicate ID error reporting ✓ RESOLVED

Decision: Collect ALL duplicate IDs and report comprehensively

Implementation (Phase 3b):
- Continue scanning all sources even after finding first duplicate
- Collect all duplicate IDs in a data structure
- If ≤10 duplicates: report in stderr error message with specific IDs
- If >10 duplicates: write to =initialization-error_duplicate-ids.org=
- Org file format:
  - =* <ID>= at level 1 (each duplicate ID, sorted alphabetically)
  - =** <source-nickname>= at level 2 (each source containing that ID, sorted alphabetically)
- Also report error count via stderr
- Test verifies complete org file content with exact string comparison

Rationale: Better user experience - see all problems at once instead of iteratively fixing. Sorted output improves debugging and enables robust testing.

** 3. Error handling during multi-source loading ✓ RESOLVED

Decision: Collect ALL file reading errors and report comprehensively

Implementation (Phase 3b):
- Continue trying to load from all sources even after errors
- Collect all unreadable file errors
- Write to =initialization-error_unreadable-skg-files.org=
- Org file format:
  - =* <filename>= at level 1 (each unreadable file, sorted alphabetically by path)
  - =** <source-nickname>= at level 2 (which source(s) contained it)
  - =*** Error: <error-message>= at level 3 (the actual error)
- Also report error count via stderr
- Test verifies org file structure with exact assertions

Rationale: Help users fix all problems at once; especially important for large repositories. Sorted output improves consistency.

** 4. Internal read_skg_files TODO comment ✓ RESOLVED

Decision: Remove the misleading TODO comment

The =read_skg_files= function (line 27 in multiple_nodes.rs) has a TODO about determining source, but this is misleading. The function works correctly - its caller =read_all_skg_files_from_sources= sets the source field appropriately.

Action: Remove TODO comment as part of Phase 3 cleanup

** 5. What if a node's source is missing or invalid? ✓ RESOLVED

Decision: Different handling for SkgNode vs OrgNode

For =SkgNode= (disk representation):
- Source is mandatory (=String=, not =Option<String>=)
- Type system prevents SkgNode without source
- If somehow a SkgNode has source that doesn't exist in config: fail fast during save with clear error

For =OrgNodeMetadata= (buffer representation):
- Source is =Option<String>= (may be None)
- Validation in Phase 7 will check that root nodes have sources
- Non-root nodes inherit source from parent (Phase 6)
- If validation fails: clear error message before any disk operations

This is already handled by design decisions from Phase 1.

Rationale:
- Fail-fast prevents data corruption
- Clear error messages help users fix configuration issues
- Type system provides compile-time safety where possible

* Remaining Open Questions

After stakeholder review, the following questions still need clarification:

** 1. How to determine source when reading individual nodes (Phase 5)

In 10 locations, individual nodes are read from disk and source is hardcoded to "main". When implementing Phase 5, how should we determine the correct source?

Options:
1. Pass source as a parameter to all read functions (requires updating many call sites)
2. Infer source from file path by comparing against all source paths in config (fragile, path manipulation issues)
3. Require callers to know the source beforehand (might not always be possible)

Related locations:
- =read_node_from_id()= in =rust/media/file_io/one_node.rs=
- =fetch_aliases_from_file()= in =rust/media/file_io/one_node.rs=
- Various read operations in merge, rebuild, save, and content_view modules

Current behavior: All set source to "main" with TODO comments

Note: See =multi-source/phase5-locations.md= for detailed breakdown of all Phase 5 locations with clickable links.

* Next Steps

Phases 1, 2, 3 (including 3b enhancements) are complete. Next steps:

1. **Phase 5: Path Generation and File Writing**
   - Update =path_from_pid= signature to accept source parameter
   - Update all 11+ call sites of =path_from_pid=
   - Remove remaining temporary "main" hardcoding (10 locations)
   - Test writing to multiple source directories
   - See =multi-source/phase5-locations.md= for complete location breakdown

3. **Continue through remaining phases sequentially**
   - Each phase builds on previous
   - Run tests after each phase
   - All tests should continue passing
