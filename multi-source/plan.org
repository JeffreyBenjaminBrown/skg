#+title: Multi-Source Data Integration - Implementation Plan
#+date: 2025-11-11

* Overview

This document outlines the plan for refactoring Skg to support multiple data sources instead of a single =skg_folder=. Each source will have a path, nickname, and ownership flag.

* Current State

** Configuration
Currently, =skgconfig.toml= contains a single =skg_folder= field (PathBuf) that points to where all .skg files are stored.

Location: =rust/types/misc.rs:20-31=

** File Loading
At startup (=rust/init.rs:25-45=):
1. =read_skg_files()= scans =config.skg_folder= for all .skg files
2. Each file is parsed into a =SkgNode=
3. All nodes are loaded into TypeDB and Tantivy

** Path Generation
=path_from_pid()= (=rust/util.rs:13-23=) dynamically constructs file paths:
- Takes =config= and =pid= (primary ID)
- Returns: =config.skg_folder / pid.skg=

** Saving
When saving (=rust/save.rs=, =rust/media/file_io/multiple_nodes.rs:32-54=):
- All .skg files are written to =config.skg_folder=
- Filename is determined by primary ID

* Target State

** Configuration Structure
Replace =skg_folder: PathBuf= with a map of sources.

Configuration will use =HashMap<String, SkgfileSource>= where:
- Key: nickname (String)
- Value: SkgfileSource struct

Each =SkgfileSource= has:
- =path: PathBuf= - directory containing .skg files
- =nickname: String= - unique identifier (duplicated as map key for convenience)
- =user_owns_it: bool= - whether user can modify nodes from this source

TOML format (array of tables):
#+begin_src toml
[[sources]]
nickname = "main"
path = "data/skg"
user_owns_it = true

[[sources]]
nickname = "shared"
path = "data/shared-skg"
user_owns_it = false
#+end_src

Note: Serde can deserialize =[[sources]]= array into a HashMap by using nickname as key.

** SkgNode Changes
Add =source: String= field:
- Position: after =aliases=, before =ids=
- Mandatory field
- NOT serialized to .skg files (inferred from file location)

** TypeDB Schema Changes
Add to =schema.tql= (after =attribute id=):
#+begin_src tql
attribute source, value string;
#+end_src

Every =node= entity must own this attribute:
#+begin_src tql
entity node,
  owns id @key,
  owns source,
  ...
#+end_src

** OrgNodeMetadata Changes
Add =source: Option<String>= field after =id= (=rust/types/orgnode.rs:16-20=).

Represented in s-expression as: =(source nickname)=

Similar to =(id abc123)=.

** Save Logic Changes
*** Source Inheritance
When processing orgnodes for save:
- If orgnode has no associated source, inherit from parent
- Source determines target directory for writing .skg file
- Users can only create nodes as roots (which must have explicit source) or as children (which inherit)

*** Validation
Before saving, validate that all root nodes have a source.

Add new error variant to =BufferValidationError=:
#+begin_src rust
RootWithoutSource (OrgNode)
#+end_src

Location: =rust/types/errors.rs:5-33=

*** Foreign Data Handling
Foreign data (where =user_owns_it = false=) has special semantics:

**** What Users CAN Do
- View foreign nodes (included in content views)
- Create links to foreign nodes
- Subscribe to foreign nodes
- Include foreign nodes in saved buffers (if unmodified)

**** What Users CANNOT Do
- Modify title, body, or contents of foreign nodes
- Delete foreign nodes
- Create new nodes in foreign sources

**** Save Validation for Foreign Data
When saving a buffer containing foreign nodes:
1. Extract =SkgNode= from the =OrgNode= (as normal)
2. Read corresponding =SkgNode= from disk
3. Compare: =title=, =body=, and =contains= fields
4. If identical: allow save (skip writing this node)
5. If different: reject save with error

**Exception for indefinitive nodes:**
- Indefinitive orgnodes from foreign sources are allowed in buffers
- They do NOT append content to the foreign node
- Treated as read-only views, even if marked indefinitive

* Required Code Changes

** 1. Configuration (=rust/types/misc.rs=)

*** Define SkgfileSource struct
#+begin_src rust
#[derive(Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]
pub struct SkgfileSource {
  pub nickname: String,      // Duplicated as map key for convenience
  pub path: PathBuf,
  pub user_owns_it: bool,
}
#+end_src

*** Modify SkgConfig
Replace:
#+begin_src rust
pub skg_folder: PathBuf,
#+end_src

With:
#+begin_src rust
pub sources: HashMap<String, SkgfileSource>,
#+end_src

*** Custom Deserialization
Need custom deserialize to convert =[[sources]]= TOML array into HashMap:
#+begin_src rust
// In SkgConfig, use:
#[serde(deserialize_with = "deserialize_sources")]
pub sources: HashMap<String, SkgfileSource>,

fn deserialize_sources<'de, D>(
  deserializer: D
) -> Result<HashMap<String, SkgfileSource>, D::Error>
where D: Deserializer<'de>
{
  let sources_vec: Vec<SkgfileSource> = Vec::deserialize(deserializer)?;
  let mut map = HashMap::new();
  for source in sources_vec {
    map.insert(source.nickname.clone(), source);
  }
  Ok(map)
}
#+end_src

*** Add helper methods
- =get_source(&self, nickname: &str) -> Option<&SkgfileSource>=
- =get_source_path(&self, nickname: &str) -> Option<&PathBuf>=
- =user_owns_source(&self, nickname: &str) -> bool=

** 2. SkgNode Type (=rust/types/skgnode.rs=)

Add field after =aliases=:
#+begin_src rust
pub source: String,

#[serde(skip_serializing, skip_deserializing)]
#+end_src

Note: Use =serde(skip)= to prevent writing to .skg files.

** 3. TypeDB Schema (=schema.tql=)

Add after line 4:
#+begin_src tql
attribute source, value string;
#+end_src

Modify =entity node= (after line 42):
#+begin_src tql
entity node,
  owns id @key,
  owns source,
  ...
#+end_src

** 4. OrgNodeMetadata (=rust/types/orgnode.rs=)

Add field after =id=:
#+begin_src rust
pub source: Option<String>,
#+end_src

** 5. Metadata Serialization (=rust/serve/parse_headline_md_sexp.rs=)

*** In =orgnodemd_to_string= (lines 39-116)
After the =id= serialization (line 45-46), add:
#+begin_src rust
if let Some(ref source) = metadata.source {
  parts.push(format!("(source {})", source));
}
#+end_src

*** In =parse_metadata_to_orgnodemd= (lines 190-235)
Add pattern matching for ="source"= (similar to ="id"= at lines 220-225):
#+begin_src rust
"source" => {
  if items.len() != 2 {
    return Err("source requires exactly one value".to_string());
  }
  let value: String = atom_to_string(&items[1])?;
  result.source = Some(value);
},
#+end_src

** 6. File Loading (=rust/media/file_io/multiple_nodes.rs=)

Create new function:
#+begin_src rust
pub fn read_all_skg_files_from_sources(
  sources: &HashMap<String, SkgfileSource>
) -> io::Result<Vec<SkgNode>>
#+end_src

For each source:
1. Call =read_skg_files(source.path)=
2. Set =source= field on each returned =SkgNode= to =source.nickname=
3. Accumulate all nodes
4. Check for duplicate IDs across sources (fail fast if found)

** 7. Initialization (=rust/init.rs=)

Modify =initialize_dbs= (lines 25-45):
- Replace =read_skg_files(skg_folder_str)=
- With =read_all_skg_files_from_sources(&config.sources)=

** 8. Path Generation (=rust/util.rs=)

Modify =path_from_pid= signature (lines 13-23):
#+begin_src rust
pub fn path_from_pid(
  config: &SkgConfig,
  source: &str,  // Add this parameter
  pid: ID,
) -> String
#+end_src

Implementation:
1. Look up source by nickname in =config.sources=
2. Use =source.path= instead of =config.skg_folder=
3. Join with =pid.skg=

** 9. TypeDB Node Creation (=rust/media/typedb/nodes.rs=)

Modify =create_node= (lines 121-140):
- Add =source= attribute to the insert query
- Use =node.source= value

** 10. Validation (=rust/types/errors.rs=)

Add variant to =BufferValidationError=:
#+begin_src rust
RootWithoutSource (OrgNode),
#+end_src

** 11. Buffer Validation (=rust/save/buffer_to_orgnodes/validate_tree.rs=)

Add validation in =find_buffer_errors_for_saving= (lines 18-129):

After line 46, add:
#+begin_src rust
let root_errors = validate_roots_have_sources(trees);
errors.extend(root_errors);
#+end_src

Create new function:
#+begin_src rust
fn validate_roots_have_sources(
  trees: &[Tree<OrgNode>]
) -> Vec<BufferValidationError> {
  let mut errors = Vec::new();
  for tree in trees {
    let root = tree.root().value();
    if root.metadata.source.is_none() {
      errors.push(BufferValidationError::RootWithoutSource(root.clone()));
    }
  }
  errors
}
#+end_src

** 12. Source Inheritance During Save

Modify =add_missing_info_dfs= in =rust/save/buffer_to_orgnodes/add_missing_info.rs= (lines 48-78):

Pass parent's source down to children:
#+begin_src rust
fn add_missing_info_dfs(
  mut node_ref: ego_tree::NodeMut<OrgNode>,
  parent_treatment: Option<RelToParent>,
  parent_source: Option<String>,  // Add this
)
#+end_src

Add function:
#+begin_src rust
fn inherit_source_if_needed(
  node: &mut OrgNode,
  parent_source: Option<String>
) {
  if node.metadata.source.is_none() {
    node.metadata.source = parent_source;
  }
}
#+end_src

Call this before processing children.

** 13. File Writing

Modify =write_all_nodes_to_fs= in =rust/media/file_io/multiple_nodes.rs= (lines 32-54):

Change signature:
#+begin_src rust
pub fn write_all_nodes_to_fs(
  nodes: Vec<SkgNode>,
  config: &SkgConfig,  // Change to reference
) -> io::Result<usize>
#+end_src

For each node:
1. Look up source directory using =node.source= and =config=
2. Create directory if needed
3. Write to =source_path / pid.skg=

** 14. Error Display (=rust/types/errors.rs=)

Update =impl Display for BufferValidationError= to handle =RootWithoutSource=.

** 15. SkgNode Creation from OrgNode

Modify =mk_skgnode= in =rust/save/orgnodes_to_instructions/to_dirty_instructions.rs= (lines 51-73):

Add source field:
#+begin_src rust
source: orgnode.metadata.source.clone()
  .ok_or_else(|| "SkgNode missing source".to_string())?,
#+end_src

** 16. Foreign Data Validation During Save

Add new error type to =rust/types/errors.rs=:
#+begin_src rust
ModifiedForeignNode(ID, String),  // (node_id, source_nickname)
#+end_src

Create new validation function in =rust/save/validate_foreign_nodes.rs=:
#+begin_src rust
pub fn validate_foreign_nodes(
  instructions: &[SaveInstruction],
  config: &SkgConfig,
) -> Result<Vec<SaveInstruction>, Vec<BufferValidationError>> {
  // For each instruction:
  // 1. Check if node.source is foreign (user_owns_it = false)
  // 2. If foreign and NOT indefinitive:
  //    a. Read corresponding SkgNode from disk
  //    b. Compare title, body, contains
  //    c. If different: add ModifiedForeignNode error
  //    d. If same: filter out from write instructions
  // 3. If foreign and indefinitive:
  //    - Filter out from write instructions (no append)
  // Return filtered instructions or errors
}
#+end_src

Call this in =rust/save.rs= after instruction generation, before filesystem/TypeDB updates.

** 17. Source Path Validation

In =rust/media/file_io/misc.rs=, add:
#+begin_src rust
pub fn validate_source_paths(
  sources: &HashMap<String, SkgfileSource>
) -> io::Result<()> {
  for (nickname, source) in sources.iter() {
    if !source.path.exists() {
      if source.user_owns_it {
        // Create directory for owned sources
        fs::create_dir_all(&source.path)?;
        eprintln!("Created directory for source '{}': {:?}",
                  nickname, source.path);
      } else {
        // Fail for foreign sources
        return Err(io::Error::new(
          io::ErrorKind::NotFound,
          format!("Foreign source '{}' path does not exist: {:?}",
                  nickname, source.path)));
      }
    }
  }
  Ok(())
}
#+end_src

Call this immediately after loading config in =load_config=.

** 18. Config Migration Script

Create =scripts/migrate-configs.sh= to update all skgconfig.toml files:
#+begin_src bash
#!/bin/bash
# Find all skgconfig.toml files and convert them

find . -name "skgconfig.toml" -type f | while read config_file; do
  echo "Migrating $config_file"
  # Read old skg_folder value
  # Generate new [[sources]] format with nickname="main"
  # Rewrite file
done
#+end_src

Or implement in Rust as a one-time utility program.

* Resolved Design Decisions

These decisions have been finalized based on stakeholder input:

** 1. Type Names and Structure
- Source type named =SkgfileSource= (not DataSource)
- Config uses =HashMap<String, SkgfileSource>= (not Vec)
- Nickname stored both as map key and in struct for convenience

** 2. Configuration Format: Array of Tables
Use TOML =[[sources]]= array syntax:
#+begin_src toml
[[sources]]
nickname = "main"
path = "data/skg"
user_owns_it = true
#+end_src

Requires custom deserializer to convert array into HashMap keyed by nickname.

** 3. Duplicate IDs: Fail Fast
If the same ID exists in multiple sources, fail during load with clear error.
Preserves ID uniqueness invariant enforced by TypeDB.

** 4. Default Source: Not an Issue
- Root nodes MUST have explicit source (validation error otherwise)
- Non-root nodes inherit from parent
- No need for "default" source concept

** 5. Source Path Validation
Validate during config load:
- If path doesn't exist and =user_owns_it = true=: create directory
- If path doesn't exist and =user_owns_it = false=: fail with error
- Prevents runtime surprises

** 6. user_owns_it Semantics
*** What users CAN do with foreign sources (=user_owns_it = false=):
- View nodes (build content views)
- Create links to nodes
- Subscribe to nodes
- Include unmodified foreign nodes in saved buffers

*** What users CANNOT do:
- Modify title, body, or contents of foreign nodes
- Delete foreign nodes
- Create new nodes in foreign sources

*** Save validation:
- Compare OrgNode-derived SkgNode with disk version
- If title, body, or contains differ: reject save
- If identical: allow (but skip writing)
- Indefinitive foreign nodes: allowed in buffer but don't append content

** 7. Migration Strategy: No Backward Compatibility
- Breaking change: =skg_folder= field removed entirely
- All existing config files must be updated
- Use script or manual process to migrate configs
- Application is not in production yet, so acceptable

** 8. TypeDB and Tantivy Updates
- TypeDB: Add =source= attribute to all nodes
- Tantivy: Add =source= field to indexed documents
- Queries: Source-agnostic initially, can add filters later

** 9. File Format Clarification
- .skg files: YAML format (unchanged)
- config files: TOML format (unchanged)
- =source= field: NOT in .skg files (inferred from file path)

** 10. API Changes: None Required
TCP API endpoints work transparently with source metadata.
Future enhancement: add "list sources" endpoint.

** 11. Root Node Definition: Tree Forest Roots
Roots are top-level nodes in =Vec<Tree<OrgNode>>= (no org-parent).
Check =tree.root().value()= for each tree.

** 12. Source Changes: Deferred
Moving nodes between sources is a future enhancement.
Initially, source is immutable after creation.

** 13. Error Types
- =RootWithoutSource(OrgNode)= - root missing source metadata
- =ModifiedForeignNode(ID, String)= - attempted modification of foreign data

** 14. Test Data Updates
- Update all on-disk config files to new format (via script or direct edit)
- Generate in-RAM configs using test helper function
- Minimal disruption: most tests use single source

* Implementation Order

** Phase 1: Core Data Structures and Config Migration
1. Add =SkgfileSource= struct to =rust/types/misc.rs=
2. Add =sources: HashMap<String, SkgfileSource>= to =SkgConfig= with custom deserializer
3. **Run migration script/manual process to update all config files**
4. Remove =skg_folder= field from =SkgConfig=
5. Add helper methods to SkgConfig (=get_source=, =get_source_path=, =user_owns_source=)
6. Add =source= field to =SkgNode= (initially =Option<String>=)
7. Add =source= field to =OrgnodeMetadata= (=Option<String>=)
8. Update TypeDB schema with =source= attribute
9. Fix compilation errors from removed =skg_folder=
10. Update test helper to generate configs with HashMap

** Phase 2: Source Path Validation
1. Implement =validate_source_paths= in =rust/media/file_io/misc.rs=
2. Call from =load_config= immediately after parsing
3. Add tests for path validation logic

** Phase 3: File Loading with Sources
1. Implement =read_all_skg_files_from_sources= with HashMap parameter
2. Add duplicate ID detection across sources
3. Update =initialize_dbs= to use new loading function
4. Add tests for multi-source loading
5. Add test fixtures with multiple source directories

** Phase 4: Metadata Serialization and Parsing
1. Update =orgnodemd_to_string= to serialize source
2. Update =parse_metadata_to_orgnodemd= to parse source
3. Add tests for source in metadata s-expressions
4. Update test utilities (=strip_id_from_metadata_struct= â†’ also strip source)

** Phase 5: Path Generation and File Writing
1. Update =path_from_pid= signature to accept source parameter
2. Find and update all call sites of =path_from_pid=
3. Modify =write_all_nodes_to_fs= to use source-specific paths
4. Test writing to multiple source directories

** Phase 6: Source Inheritance During Save
1. Modify =add_missing_info_dfs= to accept and pass parent source
2. Implement =inherit_source_if_needed= helper
3. Update recursive calls to pass source down tree
4. Add tests for source inheritance from parent to children

** Phase 7: Validation and Error Handling
1. Add =RootWithoutSource(OrgNode)= to =BufferValidationError=
2. Add =ModifiedForeignNode(ID, String)= to =BufferValidationError=
3. Implement =validate_roots_have_sources=
4. Integrate root validation into =find_buffer_errors_for_saving=
5. Update =impl Display for BufferValidationError=
6. Add tests for root validation

** Phase 8: Foreign Data Validation
1. Create =rust/save/validate_foreign_nodes.rs= module
2. Implement =validate_foreign_nodes= function
3. Integrate into save pipeline in =rust/save.rs=
4. Add tests for:
   - Unmodified foreign nodes (allowed)
   - Modified foreign nodes (rejected)
   - Indefinitive foreign nodes (filtered, no append)
   - Owned nodes (unchanged behavior)

** Phase 9: Make Source Mandatory
1. Change =SkgNode.source= from =Option<String>= to =String=
2. Update =mk_skgnode= to require source (error if missing)
3. Fix any compilation errors
4. Update all test fixtures to include sources
5. Run full test suite

** Phase 10: TypeDB and Tantivy Integration
1. Update =create_node= in TypeDB to include source attribute
2. Update =create_all_nodes= calls
3. Add source field to Tantivy schema
4. Update =update_index_with_nodes= to index source
5. Test database initialization with sources

** Phase 11: Polish and Documentation
1. Add source field to all error messages where relevant
2. Update OVERVIEW.org with multi-source model
3. Update api-and-formats.md if needed
4. Add comments explaining foreign data validation
5. Performance testing with multiple sources
6. Consider adding "list sources" API endpoint (optional)

* Testing Strategy

** Unit Tests
- Config parsing with multiple sources and HashMap structure
- Custom deserializer for =[[sources]]= array to HashMap
- Duplicate ID detection across sources
- Source inheritance logic (parent to child)
- Path generation with source parameter
- Validation of roots without sources
- Foreign node validation:
  - Unmodified foreign nodes (pass)
  - Modified foreign nodes (fail)
  - Indefinitive foreign nodes (filter)
- Source path validation (create owned, fail foreign)

** Integration Tests
- Load from multiple source directories simultaneously
- Save to different sources based on node source field
- Mixed ownership scenarios (=user_owns_it=)
- Foreign data in views (viewable but not modifiable)
- Attempting to modify foreign data (should error)
- Source inheritance through multi-level trees
- Config migration (verify all configs updated correctly)

** Test Fixtures Needed
1. Multi-source config.toml files with =[[sources]]= format
2. Directory structure with multiple source folders:
   - data/skg-owned (user_owns_it=true)
   - data/skg-foreign (user_owns_it=false)
3. .skg files in each source directory
4. Nodes with source metadata in org format: =(skg (id _) (source nickname))=
5. Read-only source scenarios with foreign data
6. Test helper for generating HashMap-based configs

* Risk Assessment

** High Risk
- **Breaking change to config format**: No backward compatibility, all configs must be updated
  - *Mitigation*: Migration script/process to update all configs before code changes
  - *Impact*: Application not in production, acceptable
- **TypeDB schema change**: Requires database rebuild, impacts existing data
  - *Mitigation*: Database is rebuilt from .skg files on each startup
  - *Impact*: No persistent TypeDB data loss concern
- **Source field is mandatory**: All code paths must set it correctly
  - *Mitigation*: Compiler will catch missing source assignments
  - *Impact*: Start with Option<String>, transition to String after validation working

** Medium Risk
- **Foreign data validation complexity**: Must compare OrgNode-derived vs disk SkgNodes
  - *Mitigation*: Isolated in single module, well-tested
  - *Impact*: Complex logic but contained
- **HashMap custom deserializer**: TOML array to HashMap conversion
  - *Mitigation*: Standard Serde pattern, test thoroughly
  - *Impact*: If broken, config parsing fails immediately (fail fast)
- **Path construction changes**: Many call sites to update for =path_from_pid=
  - *Mitigation*: Compiler will find all call sites
  - *Impact*: Mechanical refactoring, straightforward
- **Test fixture updates**: Time-consuming but straightforward
  - *Mitigation*: Update incrementally, phase by phase
  - *Impact*: Test failures will be obvious

** Low Risk
- **Metadata serialization**: Well-contained in one module
- **Validation additions**: Incremental to existing validation
- **Source path validation**: Simple directory check/create logic
- **Duplicate ID detection**: O(n) HashSet check, straightforward

* Success Criteria

Core Functionality:
- [ ] Can load .skg files from multiple directories simultaneously
- [ ] Each node tracks its source (mandatory field)
- [ ] Source appears in org-mode metadata as =(source nickname)=
- [ ] Nodes inherit source from parent during save
- [ ] Root nodes without source are rejected with clear error
- [ ] Files are written to correct source directory based on node.source

Foreign Data Handling:
- [ ] Foreign nodes can be viewed in content views
- [ ] Unmodified foreign nodes can be included in saved buffers
- [ ] Modified foreign nodes trigger save errors
- [ ] Indefinitive foreign nodes don't append content
- [ ] Cannot create new nodes in foreign sources

Data Integrity:
- [ ] TypeDB stores source attribute for all nodes
- [ ] Tantivy indexes source for all documents
- [ ] Duplicate IDs across sources detected and rejected
- [ ] Source paths validated at startup

Testing and Migration:
- [ ] All existing tests pass with updated fixtures
- [ ] All config files migrated to new format
- [ ] Test helper generates HashMap-based configs
- [ ] Multi-source integration tests pass

Documentation:
- [ ] OVERVIEW.org updated with multi-source model
- [ ] Plan document captures all design decisions
- [ ] Code comments explain foreign data validation
- [ ] Error messages include source information where relevant

* Remaining Open Questions

After stakeholder review, the following questions still need clarification:

** None Currently

All major design decisions have been resolved. Ready to begin implementation.

* Next Steps

1. **Create and run config migration script/process**
   - Update all skgconfig.toml files to =[[sources]]= format
   - Verify all configs parse correctly

2. **Begin Phase 1 implementation**
   - Add SkgfileSource type
   - Add HashMap field to SkgConfig
   - Implement custom deserializer
   - Remove skg_folder field

3. **Update test infrastructure**
   - Create test helper for HashMap configs
   - Update basic tests to ensure config parsing works

4. **Proceed through phases sequentially**
   - Each phase builds on previous
   - Run tests after each phase
   - Commit working increments
