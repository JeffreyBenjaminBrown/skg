#+title: Surprises and Discoveries During Multi-Source Implementation
#+date: 2025-11-11

This document tracks unexpected findings during implementation that may require design decisions.

* Resolved

** 1. SkgConfig cannot derive Hash anymore

*** Issue
HashMap doesn't implement Hash, so SkgConfig can no longer derive Hash.

*** Resolution
Removed =Hash= from SkgConfig's derive macro. Need to verify if any code was using SkgConfig as a HashMap key or in a HashSet (unlikely).

*** Impact
Low - SkgConfig is typically not used as a hash key.

*** Status
✓ Resolved - =Hash= removed permanently from derive macro

** 3. Source reconciliation requires metadata parsing updates

*** Issue
Implementing =reconciled_source()= function revealed that org-mode metadata parsing and rendering didn't support the =source= field yet.

*** Resolution
Added source field support to two functions in =rust/serve/parse_headline_md_sexp.rs=:
- =parse_orgnode_metadata_sexp()=: Added "source" case to parse =(source main)= syntax
- =orgnodemd_to_string()=: Added source rendering to write source back to org format

Also updated 5 test files to include =(source main)= in their test org-mode data:
- =tests/new/orgnodes_to_instructions/reconcile_dup_instructions.rs= (3 tests)
- =tests/save/parentIgnores_and_indefinitive.rs=
- =tests/typedb/update_typedb_from_saveinstructions.rs=

*** Impact
Source fields can now be parsed from and written to org-mode format. This is required for source reconciliation during save operations.

*** Status
✓ Resolved - Source parsing and rendering fully implemented

** 4. Source field made mandatory in SkgNode

*** Issue
Originally source was =Option<String>= in SkgNode, but this created complications when deserializing from .skg files (which don't contain source).

*** Resolution
Changed =SkgNode.source= from =Option<String>= to =String= (mandatory). OrgnodeMetadata.source remains =Option<String>= since user input may not specify source.

Updated all file reading operations to set source after deserialization:
- =rust/media/file_io/one_node.rs=: Added source setting in =read_node_from_id()= and =fetch_aliases_from_file()=
- =rust/media/file_io/multiple_nodes.rs=: Set source in =read_all_nodes_from_fs()=
- =rust/merge/mergeInstructionTriple.rs=: Set source after reading acquirer and acquiree
- =rust/save/orgnodes_to_instructions/none_node_fields_are_noops.rs=: Set source after reading from disk
- =rust/rebuild/complete_aliascol.rs=: Set source after reading
- =rust/rebuild/complete_contents.rs=: Set source after reading
- =rust/mk_org_text/content_view.rs=: Set source in both functions that read nodes (2 locations)
- All test files that read nodes (3 test files, 3 locations)

All currently hardcoded to "main" with TODO comments for Phase 5.

Updated =mk_skgnode()= in =to_dirty_instructions.rs= to require source in orgnode metadata and return error if missing.

Simplified =reconciled_source()= function - no longer checks for Option, just returns the String directly.

*** Impact
Source is now required in all SkgNode instances. The code is cleaner and the type system enforces that every SkgNode has a source. Temporary workarounds set source to "main" after reading from disk.

*** Status
✓ Resolved - Source is now mandatory in SkgNode (Phase 9 completed early)

** 5. Source reconciliation needed for duplicate instructions

*** Issue
When implementing =reconcile_dup_instructions_for_one_id=, discovered that when multiple orgnodes have the same ID, we need to determine which source to use for the reconciled node.

*** Resolution
Implemented =reconciled_source()= function in =rust/save/orgnodes_to_instructions/reconcile_dup_instructions.rs= (lines 214-225).

Priority order:
1. If a definer exists, use its source
2. Otherwise, use the first indefinitive's source
3. If neither exists, return error

The function is called early in =reconcile_dup_instructions_for_one_id= to compute the canonical source before reading from disk.

*** Impact
Source reconciliation logic is now explicit and follows a clear priority: definer takes precedence over indefinitives. This ensures consistent behavior when multiple buffer orgnodes reference the same node.

*** Status
✓ Resolved - Source reconciliation implemented in Phase 1

** 6. Duplicate ID detection handles nodes with multiple IDs correctly

*** Issue
During Phase 3 implementation and testing, realized that nodes can have multiple IDs (in the =ids= vector). The duplicate detection needs to check ALL IDs in each node, not just the primary ID.

*** Resolution
The =read_all_skg_files_from_sources= function correctly iterates over all IDs in =node.ids= vector:
#+begin_src rust
for id in &node.ids {
  let id_str = id.as_str();
  if let Some(existing_source) = seen_ids.get(id_str) {
    return Err(...); // Duplicate found
  }
  seen_ids.insert(id_str.to_string(), nickname.clone());
}
#+end_src

Added specific test =test_node_with_multiple_ids_duplicate_detection= to verify this behavior.

*** Impact
Duplicate detection is thorough and catches any ID overlap, even when nodes have multiple aliases/IDs. This prevents subtle bugs where nodes with different primary IDs might share a secondary ID.

*** Status
✓ Resolved - Proper multi-ID handling implemented and tested in Phase 3

** 7. Error reporting strategy for initialization

*** Issue
During Phase 3 discussion, realized that fail-fast error handling (current behavior) is suboptimal for users. If there are multiple duplicate IDs or multiple unreadable files, users would have to fix one, restart, discover the next, etc.

*** Resolution
Decision to implement comprehensive error collection instead of fail-fast:

For duplicate IDs:
- Continue scanning all sources even after finding first duplicate
- Collect all duplicate IDs
- If ≤10: report in stderr
- If >10: write to =initialization-error_duplicate-ids.org= with org format
- Sort output: IDs alphabetically, sources alphabetically within each ID
- Add test to verify behavior

For unreadable files:
- Continue trying all sources even after errors
- Collect all file read errors
- Write to =initialization-error_unreadable-skg-files.org= with org format
- Sort output: paths alphabetically
- Add test to verify behavior

Org file format uses:
- =* <ID or filename>= at level 1
- =** <source-nickname>= at level 2
- =*** Error: <error-message>= at level 3 (for unreadable files)

Enhancement: Sorted output for determinism
- Enables full programmatic test verification instead of substring checks
- Tests generate expected content and do exact string comparison
- Easier for users to review and compare error reports
- Implemented by sorting HashMap keys into Vec before iteration

*** Impact
Better user experience - users can fix all problems at once instead of iteratively. Especially important for large repositories with many sources. Deterministic output improves debugging and testing.

*** Status
✓ Resolved - Implemented in Phase 3b (including sorted output enhancement)

* Unresolved

** 2. Temporary workarounds for compilation (Partially Resolved)

*** Issue
Phase 1 removed =skg_folder= before implementing full multi-source loading logic.

*** Temporary workarounds (updated after Phase 3)
Resolved in Phase 3:
- ✓ =rust/init.rs=: Now reads from all sources using =read_all_skg_files_from_sources=

Still pending Phase 5:
- =rust/util.rs:path_from_pid()=: Uses "main" source instead of accepting source parameter
- =rust/media/file_io/multiple_nodes.rs=: Writes only to "main" source
- =rust/save.rs=: Generic print message instead of per-source information
- 10 locations where source is hardcoded to "main" after reading from disk

*** Current status
After Phase 3:
- File loading now supports multiple sources correctly
- Duplicate ID detection across sources working
- Source field properly set during loading

Still needs Phase 5:
- Path generation still hardcoded to "main"
- File writing still hardcoded to "main"
- Individual file reads still set source to "main"

*** Status
⚠ Partially Resolved - Phase 3 complete, Phase 5 pending

See =multi-source/temporary-changes.org= for detailed breakdown of remaining workarounds.

** 8. path_from_pid call sites have different contexts (Phase 5 analysis)

*** Issue
Before implementing Phase 5, needed to understand: do callers of =path_from_pid= know the source, or do they need to look it up?

*** Discovery
Call site analysis revealed **three distinct categories** with different solutions:

**** Category A: Callers have the node object (3 sites)
- =rust/merge/fs.rs= - writing merge results (has all 3 node objects)
- =rust/media/file_io/multiple_nodes.rs= - write_all_nodes_to_fs (iterating over nodes)
- =rust/media/file_io/multiple_nodes.rs= - delete_all_nodes_from_fs (iterating over nodes)
**Solution:** Add =source= parameter to =path_from_pid=, pass =node.source=

**** Category B: Callers only have an ID (8 sites)
- =rust/media/file_io/one_node.rs= - read_node_from_id, fetch_aliases_from_file
- =rust/merge/mergeInstructionTriple.rs= - reading acquirer and acquiree by ID
- =rust/rebuild/complete_aliascol.rs= - reading parent node by ID
- =rust/rebuild/complete_contents.rs= - reading node by ID
- =rust/mk_org_text/content_view.rs= - content view (2 locations)
- =rust/save/orgnodes_to_instructions/none_node_fields_are_noops.rs= - validation
**Solution:** Query TypeDB for source (create =pid_and_source_from_id= helper)

**** Category C: Already computed source (1 site)
- =rust/save/orgnodes_to_instructions/reconcile_dup_instructions.rs= - has =reconciled_source_value= computed but not using it yet
**Solution:** Use the existing computed value

*** Impact
Need **both** approaches:
1. =path_from_pid(config, source, pid)= - when you know the source
2. TypeDB helper function - when you only have an ID and need to query source

TypeDB already stores source as an attribute, so querying it is straightforward and efficient.

*** Status
✓ Resolved - Detailed analysis in =multi-source/phase5-analysis.md=

** 9. Performance: Batch vs single-ID source lookups (Phase 5 analysis)

*** Issue
Category B call sites need to query TypeDB for source. Should we batch multiple lookups like =pids_from_ids= does, or query one at a time?

*** Analysis
Examined all Category B call sites and existing batching patterns:

Existing batch infrastructure (=pids_from_ids=):
- Used in save pipeline: collect all IDs → one TypeDB query → distribute results
- Builds disjunction (OR clauses) for all IDs in single query
- Returns =HashMap<ID, Option<ID>>=
- Pattern works well for bulk operations

Current Category B usage:
- 6 sites process single IDs one at a time (content view, validation, rebuild)
- 1 site reads 2 nodes (merge: acquirer and acquiree) - marginal benefit from batching
- Most are sequential operations, not easily batchable without major refactoring

*** Decision
Start with single-ID lookups, add batching later if profiling shows need.

Create simple helper:
#+begin_src rust
pub async fn pid_and_source_from_id(
  db_name: &str,
  driver: &TypeDBDriver,
  node_id: &ID
) -> Result<Option<(ID, String)>, Box<dyn Error>>
#+end_src

Future optimization: =pids_and_sources_from_ids= for batch lookups if needed.

*** Impact
- Simpler initial implementation
- Matches current usage patterns (mostly one-off lookups)
- Can add batching later if measurements justify it
- Avoids premature optimization

*** Status
✓ Resolved - Detailed analysis in =multi-source/phase5-batching-analysis.md=
