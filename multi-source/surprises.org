#+title: Surprises and Discoveries During Multi-Source Implementation
#+date: 2025-11-12

This document tracks unexpected findings during implementation that may require design decisions.

*Note:* Phase 6 (Source Inheritance) had no surprises - implementation followed existing alias inheritance pattern perfectly.

* Resolved

** 1. SkgConfig cannot derive Hash anymore

*** Issue
HashMap doesn't implement Hash, so SkgConfig can no longer derive Hash.

*** Resolution
Removed =Hash= from SkgConfig's derive macro. Need to verify if any code was using SkgConfig as a HashMap key or in a HashSet (unlikely).

*** Impact
Low - SkgConfig is typically not used as a hash key.

*** Status
✓ Resolved - =Hash= removed permanently from derive macro

** 3. Source reconciliation requires metadata parsing updates

*** Issue
Implementing =reconciled_source()= function revealed that org-mode metadata parsing and rendering didn't support the =source= field yet.

*** Resolution
Added source field support to two functions in =rust/serve/parse_headline_md_sexp.rs=:
- =parse_orgnode_metadata_sexp()=: Added "source" case to parse =(source main)= syntax
- =orgnodemd_to_string()=: Added source rendering to write source back to org format

Also updated 5 test files to include =(source main)= in their test org-mode data:
- =tests/new/orgnodes_to_instructions/reconcile_dup_instructions.rs= (3 tests)
- =tests/save/parentIgnores_and_indefinitive.rs=
- =tests/typedb/update_typedb_from_saveinstructions.rs=

*** Impact
Source fields can now be parsed from and written to org-mode format. This is required for source reconciliation during save operations.

*** Status
✓ Resolved - Source parsing and rendering fully implemented

** 4. Source field made mandatory in SkgNode

*** Issue
Originally source was =Option<String>= in SkgNode, but this created complications when deserializing from .skg files (which don't contain source).

*** Resolution
Changed =SkgNode.source= from =Option<String>= to =String= (mandatory). OrgnodeMetadata.source remains =Option<String>= since user input may not specify source.

Updated all file reading operations to set source after deserialization:
- =rust/media/file_io/one_node.rs=: Added source setting in =read_node_from_id()= and =fetch_aliases_from_file()=
- =rust/media/file_io/multiple_nodes.rs=: Set source in =read_all_nodes_from_fs()=
- =rust/merge/mergeInstructionTriple.rs=: Set source after reading acquirer and acquiree
- =rust/save/orgnodes_to_instructions/none_node_fields_are_noops.rs=: Set source after reading from disk
- =rust/rebuild/complete_aliascol.rs=: Set source after reading
- =rust/rebuild/complete_contents.rs=: Set source after reading
- =rust/mk_org_text/content_view.rs=: Set source in both functions that read nodes (2 locations)
- All test files that read nodes (3 test files, 3 locations)

All currently hardcoded to "main" with TODO comments for Phase 5.

Updated =mk_skgnode()= in =to_dirty_instructions.rs= to require source in orgnode metadata and return error if missing.

Simplified =reconciled_source()= function - no longer checks for Option, just returns the String directly.

*** Impact
Source is now required in all SkgNode instances. The code is cleaner and the type system enforces that every SkgNode has a source. Temporary workarounds set source to "main" after reading from disk.

*** Status
✓ Resolved - Source is now mandatory in SkgNode (Phase 9 completed early)

** 5. Source reconciliation needed for duplicate instructions

*** Issue
When implementing =reconcile_dup_instructions_for_one_id=, discovered that when multiple orgnodes have the same ID, we need to determine which source to use for the reconciled node.

*** Initial Resolution (Phase 1)
Implemented =reconciled_source()= function in =rust/save/orgnodes_to_instructions/reconcile_dup_instructions.rs= (lines 214-225).

Initial priority order (INCORRECT - will be fixed in Phase 7):
1. If a definer exists, use its source
2. Otherwise, use the first indefinitive's source (=indefinitives[0].0.source=)
3. If neither exists, return error

The function is called early in =reconcile_dup_instructions_for_one_id= to compute the canonical source before reading from disk.

*** Critical Insight (Discovered before Phase 7)
*The initial approach is wrong*: If two orgnodes have the same ID, they MUST have the same source.
We shouldn't just take the first source - we should:
1. Collect ALL sources from definer and all indefinitives into a =HashSet=
2. Verify the set is a singleton (exactly one unique source)
3. If not singleton, that's a validation error that should be reported to the user

This validation will be implemented in Phase 7 by:
- Adding =InconsistentSources(ID, HashSet<String>)= to =BufferValidationError=
- Updating =reconciled_source= to validate source consistency
- Propagating the error up so it's reported alongside other validation errors

*** Impact
Phase 7 fix will ensure data consistency: nodes with the same ID must come from the same source. This catches user errors where they might have manually set inconsistent sources in metadata.

*** Status
⚠ Partial - Basic reconciliation implemented (Phase 1), validation to be added (Phase 7)

** 6. Duplicate ID detection handles nodes with multiple IDs correctly

*** Issue
During Phase 3 implementation and testing, realized that nodes can have multiple IDs (in the =ids= vector). The duplicate detection needs to check ALL IDs in each node, not just the primary ID.

*** Resolution
The =read_all_skg_files_from_sources= function correctly iterates over all IDs in =node.ids= vector:
#+begin_src rust
for id in &node.ids {
  let id_str = id.as_str();
  if let Some(existing_source) = seen_ids.get(id_str) {
    return Err(...); // Duplicate found
  }
  seen_ids.insert(id_str.to_string(), nickname.clone());
}
#+end_src

Added specific test =test_node_with_multiple_ids_duplicate_detection= to verify this behavior.

*** Impact
Duplicate detection is thorough and catches any ID overlap, even when nodes have multiple aliases/IDs. This prevents subtle bugs where nodes with different primary IDs might share a secondary ID.

*** Status
✓ Resolved - Proper multi-ID handling implemented and tested in Phase 3

** 7. Error reporting strategy for initialization

*** Issue
During Phase 3 discussion, realized that fail-fast error handling (current behavior) is suboptimal for users. If there are multiple duplicate IDs or multiple unreadable files, users would have to fix one, restart, discover the next, etc.

*** Resolution
Decision to implement comprehensive error collection instead of fail-fast:

For duplicate IDs:
- Continue scanning all sources even after finding first duplicate
- Collect all duplicate IDs
- If ≤10: report in stderr
- If >10: write to =initialization-error_duplicate-ids.org= with org format
- Sort output: IDs alphabetically, sources alphabetically within each ID
- Add test to verify behavior

For unreadable files:
- Continue trying all sources even after errors
- Collect all file read errors
- Write to =initialization-error_unreadable-skg-files.org= with org format
- Sort output: paths alphabetically
- Add test to verify behavior

Org file format uses:
- =* <ID or filename>= at level 1
- =** <source-nickname>= at level 2
- =*** Error: <error-message>= at level 3 (for unreadable files)

Enhancement: Sorted output for determinism
- Enables full programmatic test verification instead of substring checks
- Tests generate expected content and do exact string comparison
- Easier for users to review and compare error reports
- Implemented by sorting HashMap keys into Vec before iteration

*** Impact
Better user experience - users can fix all problems at once instead of iteratively. Especially important for large repositories with many sources. Deterministic output improves debugging and testing.

*** Status
✓ Resolved - Implemented in Phase 3b (including sorted output enhancement)

** 10. Async propagation from TypeDB queries (Phase 5)

*** Issue
When =pid_and_source_from_id= helper was created to query TypeDB for source attribute, it had to be async (all TypeDB operations are async). This forced many calling functions to become async.

*** Cascade
Direct callers that became async:
- =fetch_aliases_from_file= (rust/media/file_io/one_node.rs)
- =read_node_from_id= (rust/media/file_io/one_node.rs)
- =clobber_none_fields_with_data_from_disk= (rust/save/orgnodes_to_instructions/none_node_fields_are_noops.rs)

Indirect callers that became async (called the above):
- =check_for_and_modify_if_repeated= (rust/rebuild/complete_contents.rs)
- =completeContents= (rust/rebuild/complete_contents.rs)
- =completeAliasCol= (rust/rebuild/completeAliasCol.rs)

Test impact:
- All tests calling these functions needed async conversion
- tests/save/none_node_fields_are_noops.rs (4 tests)
- tests/rebuild/complete_contents.rs (helper + 4 tests)
- All needed =run_with_test_db= wrapper pattern
- All needed =Box::pin(async move { ... })= closures

*** Resolution
Accepted async propagation as necessary cost of TypeDB integration. Updated all affected code and tests.

*** Impact
Medium - Mechanical but time-consuming. ~200 lines of test code updated. All code paths now properly handle async TypeDB queries.

*** Status
✓ Resolved - All 122 tests passing after updates

** 11. Source nickname consistency bug in test infrastructure (Phase 5)

*** Issue
Discovered subtle bug: =populate_test_db_from_fixtures= used "test" as source nickname, but =setup_test_tantivy_and_typedb_dbs= created config with "main" source.

When Phase 5 code called =path_from_pid_and_source(config, source, pid)= with =source="test"= (from TypeDB), it panicked because config only had "main" source in HashMap.

*** Root cause
Two different functions setting up test infrastructure used inconsistent source nicknames:
- =populate_test_db_from_fixtures=: Created source "test", loaded nodes with source="test"
- =setup_test_tantivy_and_typedb_dbs=: Created config with source "main"

Phase 5 exposed this because:
1. Nodes loaded with source="test" (stored in TypeDB)
2. Config has source "main"
3. =pid_and_source_from_id= queries TypeDB, returns "test"
4. =path_from_pid_and_source(config, "test", ...)= fails - no "test" in config.sources HashMap

*** Resolution
Changed =populate_test_db_from_fixtures= to use "main" to match =setup_test_tantivy_and_typedb_dbs=.

*** Impact
Low once understood, but tricky to diagnose. Error message ("Source 'test' not found in config") was clear once we noticed the mismatch.

*** Lesson
Source nicknames must be consistent throughout test lifecycle:
1. When creating sources HashMap for loading
2. When creating config for tests
3. When querying TypeDB and generating paths

*** Status
✓ Resolved - Changed rust/test_utils.rs:81 to use "main"

** 12. Phase ordering - TypeDB integration needed earlier than planned (Phase 5)

*** Issue
Originally planned Phase 10 (TypeDB integration) for later, but Phase 5 implementation required it immediately.

*** Why
=pid_and_source_from_id= queries TypeDB for source attribute. Without source stored in TypeDB:
- Query returns None
- Tests fail with "ID not found in database"
- Cannot complete Phase 5 without TypeDB storing source

*** Resolution
Implemented TypeDB portion of Phase 10 early:
- Updated =create_node= to include source attribute (rust/media/typedb/nodes.rs:134-140)
- Query now: =has id "{}", has source "{}"=
- Tantivy portion of Phase 10 still pending

*** Impact
Low - Single line change, straightforward implementation. But demonstrates phase dependencies weren't fully understood during planning.

*** Lesson
Dependencies between phases may force reordering. Functions that query database fields require those fields to exist first.

*** Status
✓ Resolved - Partial Phase 10 completion (TypeDB only)

* Summary

All surprises and issues discovered through Phase 5 have been resolved (as of 2025-11-11).

Key discoveries:
1. HashMap cannot derive Hash → Removed from SkgConfig (low impact)
2. Source reconciliation required metadata parsing updates → Completed in Phase 1
3. Source field made mandatory in SkgNode → Completed in Phase 9
4. Source reconciliation for duplicate instructions → Implemented in Phase 1
5. Duplicate ID detection handles multi-ID nodes correctly → Completed in Phase 3
6. Error reporting strategy: comprehensive collection > fail-fast → Completed in Phase 3b
7. Sorted output improves testing and UX → Completed in Phase 3b
8. Async propagation from TypeDB queries → Resolved in Phase 5
9. Source nickname consistency critical in tests → Fixed in Phase 5
10. Phase ordering - TypeDB needed earlier → Partial Phase 10 completed early

All 122 tests passing. Phase 6 completed. No unresolved issues blocking Phase 7 implementation.
