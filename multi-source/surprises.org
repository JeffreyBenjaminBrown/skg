#+title: Surprises and Discoveries During Multi-Source Implementation
#+date: 2025-11-11

This document tracks unexpected findings during implementation that may require design decisions.

* Resolved

** 1. SkgConfig cannot derive Hash anymore

*** Issue
HashMap doesn't implement Hash, so SkgConfig can no longer derive Hash.

*** Resolution
Removed =Hash= from SkgConfig's derive macro. Need to verify if any code was using SkgConfig as a HashMap key or in a HashSet (unlikely).

*** Impact
Low - SkgConfig is typically not used as a hash key.

*** Status
✓ Resolved - =Hash= removed permanently from derive macro

** 3. Source reconciliation requires metadata parsing updates

*** Issue
Implementing =reconciled_source()= function revealed that org-mode metadata parsing and rendering didn't support the =source= field yet.

*** Resolution
Added source field support to two functions in =rust/serve/parse_headline_md_sexp.rs=:
- =parse_orgnode_metadata_sexp()=: Added "source" case to parse =(source main)= syntax
- =orgnodemd_to_string()=: Added source rendering to write source back to org format

Also updated 5 test files to include =(source main)= in their test org-mode data:
- =tests/new/orgnodes_to_instructions/reconcile_dup_instructions.rs= (3 tests)
- =tests/save/parentIgnores_and_indefinitive.rs=
- =tests/typedb/update_typedb_from_saveinstructions.rs=

*** Impact
Source fields can now be parsed from and written to org-mode format. This is required for source reconciliation during save operations.

*** Status
✓ Resolved - Source parsing and rendering fully implemented

** 4. Source field made mandatory in SkgNode

*** Issue
Originally source was =Option<String>= in SkgNode, but this created complications when deserializing from .skg files (which don't contain source).

*** Resolution
Changed =SkgNode.source= from =Option<String>= to =String= (mandatory). OrgnodeMetadata.source remains =Option<String>= since user input may not specify source.

Updated all file reading operations to set source after deserialization:
- =rust/media/file_io/one_node.rs=: Added source setting in =read_node_from_id()= and =fetch_aliases_from_file()=
- =rust/media/file_io/multiple_nodes.rs=: Set source in =read_all_nodes_from_fs()=
- =rust/merge/mergeInstructionTriple.rs=: Set source after reading acquirer and acquiree
- =rust/save/orgnodes_to_instructions/none_node_fields_are_noops.rs=: Set source after reading from disk
- =rust/rebuild/complete_aliascol.rs=: Set source after reading
- =rust/rebuild/complete_contents.rs=: Set source after reading
- =rust/mk_org_text/content_view.rs=: Set source in both functions that read nodes (2 locations)
- All test files that read nodes (3 test files, 3 locations)

All currently hardcoded to "main" with TODO comments for Phase 5.

Updated =mk_skgnode()= in =to_dirty_instructions.rs= to require source in orgnode metadata and return error if missing.

Simplified =reconciled_source()= function - no longer checks for Option, just returns the String directly.

*** Impact
Source is now required in all SkgNode instances. The code is cleaner and the type system enforces that every SkgNode has a source. Temporary workarounds set source to "main" after reading from disk.

*** Status
✓ Resolved - Source is now mandatory in SkgNode (Phase 9 completed early)

** 5. Source reconciliation needed for duplicate instructions

*** Issue
When implementing =reconcile_dup_instructions_for_one_id=, discovered that when multiple orgnodes have the same ID, we need to determine which source to use for the reconciled node.

*** Resolution
Implemented =reconciled_source()= function in =rust/save/orgnodes_to_instructions/reconcile_dup_instructions.rs= (lines 214-225).

Priority order:
1. If a definer exists, use its source
2. Otherwise, use the first indefinitive's source
3. If neither exists, return error

The function is called early in =reconcile_dup_instructions_for_one_id= to compute the canonical source before reading from disk.

*** Impact
Source reconciliation logic is now explicit and follows a clear priority: definer takes precedence over indefinitives. This ensures consistent behavior when multiple buffer orgnodes reference the same node.

*** Status
✓ Resolved - Source reconciliation implemented in Phase 1

** 6. Duplicate ID detection handles nodes with multiple IDs correctly

*** Issue
During Phase 3 implementation and testing, realized that nodes can have multiple IDs (in the =ids= vector). The duplicate detection needs to check ALL IDs in each node, not just the primary ID.

*** Resolution
The =read_all_skg_files_from_sources= function correctly iterates over all IDs in =node.ids= vector:
#+begin_src rust
for id in &node.ids {
  let id_str = id.as_str();
  if let Some(existing_source) = seen_ids.get(id_str) {
    return Err(...); // Duplicate found
  }
  seen_ids.insert(id_str.to_string(), nickname.clone());
}
#+end_src

Added specific test =test_node_with_multiple_ids_duplicate_detection= to verify this behavior.

*** Impact
Duplicate detection is thorough and catches any ID overlap, even when nodes have multiple aliases/IDs. This prevents subtle bugs where nodes with different primary IDs might share a secondary ID.

*** Status
✓ Resolved - Proper multi-ID handling implemented and tested in Phase 3

** 7. Error reporting strategy for initialization

*** Issue
During Phase 3 discussion, realized that fail-fast error handling (current behavior) is suboptimal for users. If there are multiple duplicate IDs or multiple unreadable files, users would have to fix one, restart, discover the next, etc.

*** Resolution
Decision to implement comprehensive error collection instead of fail-fast:

For duplicate IDs:
- Continue scanning all sources even after finding first duplicate
- Collect all duplicate IDs
- If ≤10: report in stderr
- If >10: write to =initialization-error_duplicate-ids.org= with org format
- Add test to verify behavior

For unreadable files:
- Continue trying all sources even after errors
- Collect all file read errors
- Write to =initialization-error_unreadable-skg-files.org= with org format
- Add test to verify behavior

Org file format uses:
- =* <ID or filename>= at level 1
- =** <source-nickname>= at level 2
- =*** Error: <error-message>= at level 3 (for unreadable files)

*** Impact
Better user experience - users can fix all problems at once instead of iteratively. Especially important for large repositories with many sources.

*** Status
✓ Resolved - Design decided, implementation pending as Phase 3b

* Unresolved

** 2. Temporary workarounds for compilation (Partially Resolved)

*** Issue
Phase 1 removed =skg_folder= before implementing full multi-source loading logic.

*** Temporary workarounds (updated after Phase 3)
Resolved in Phase 3:
- ✓ =rust/init.rs=: Now reads from all sources using =read_all_skg_files_from_sources=

Still pending Phase 5:
- =rust/util.rs:path_from_pid()=: Uses "main" source instead of accepting source parameter
- =rust/media/file_io/multiple_nodes.rs=: Writes only to "main" source
- =rust/save.rs=: Generic print message instead of per-source information
- 10 locations where source is hardcoded to "main" after reading from disk

*** Current status
After Phase 3:
- File loading now supports multiple sources correctly
- Duplicate ID detection across sources working
- Source field properly set during loading

Still needs Phase 5:
- Path generation still hardcoded to "main"
- File writing still hardcoded to "main"
- Individual file reads still set source to "main"

*** Status
⚠ Partially Resolved - Phase 3 complete, Phase 5 pending

See =multi-source/temporary-changes.org= for detailed breakdown of remaining workarounds.
