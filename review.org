* TODO reading history
  reading upward in the git log as shown by magit
** TODO last file completely read
   rust/rebuild.rs
* changes since main
** Add Merge(ID) constructor to NodeRequest
pub enum NodeRequest {
  ContainerwardView,
  SourcewardView,
  Merge(ID),  // Request to merge another node into this one
}
** Add 'extra_ids_from_pid' in typedb::search
   +pub async fn extra_ids_from_pid(
   +  db_name: &str,
   +  driver: &TypeDBDriver,
   +  node_id: &ID,
   +) -> Result<Vec<ID>, Box<dyn Error>> {
** the merge algorithm
* TODO
** DONE Don't detect text!
You write that the string 'MERGED-' is used to classify nodes. That's dangerous. Instead, would it be feasible to define a struct 'Merge_3_SaveInstructions', with fields that specify which is the 'acquirer', which the 'acquiree', and which the 'preserver' (of the acquiree's text)?
*** Title Format - Changed acquiree_text_preserver title from "MERGED: " to "MERGED-" to avoid Tantivy query syntax conflicts with colons
** DONE The SkgNodes in the three SaveInstruction should have all the relevant information.
*** 1
Great!

Next: The information computed here:
```
    // Compute final relationship fields for acquirer
    let acquirer_final_contains : HashSet<ID> =
      updated_acquirer.contains.iter().cloned().collect();

    let mut acquirer_to_write : SkgNode = updated_acquirer.clone();

    // Combine hides_from_its_subscriptions (with filtering)
    let mut combined_hides : Vec<ID> = Vec::new();
    for list in [&updated_acquirer.hides_from_its_subscriptions,
                 &acquiree.hides_from_its_subscriptions] {
      if let Some(hides_list) = list {
        for hidden_id in hides_list {
          if !acquirer_final_contains.contains(hidden_id)
             && !combined_hides.contains(hidden_id) {
            combined_hides.push(hidden_id.clone());
          }
        }
      }
    }
    acquirer_to_write.hides_from_its_subscriptions = Some(combined_hides);

    // Combine subscribes_to
    acquirer_to_write.subscribes_to = Some(
      updated_acquirer.subscribes_to.clone().unwrap_or_default()
        .into_iter()
        .chain(acquiree.subscribes_to.clone().unwrap_or_default())
        .collect()
    );

    // Combine overrides_view_of
    acquirer_to_write.overrides_view_of = Some(
      updated_acquirer.overrides_view_of.clone().unwrap_or_default()
        .into_iter()
        .chain(acquiree.overrides_view_of.clone().unwrap_or_default())
        .collect()
    );
```
should be calculated earlier, in 'saveinstructions_from_the_merge_in_a_node'.
*** 2
Can you move the SaveInstruction-creating functions in rust/merge.rs to a new file, rust/merge/merge3saveinstructions.rs? And move the code that defines the acquirer's fields to a standalone function?
** DONE be sure this is tested
Great! Next, can you look through the tests and make sure the following two properties are being tested somewhere?

- If A is merged into B and A was hyperlinked to C, now the first child of B is hyperlinked to C.
- If A is merged into B and C was hyperlinked to A, now C is hyperlinked to B.
** DONE SkgNode serialization
Next let's work on how SkgNodes are interpreted. Currently a SkgNode's optional list fields are not written to disk if they are None, but they *are* written if they are Some([]). I want them not written to disk either way. And when they are read from disk, if they are absent, they should be read as None values.

This means writing and reading is not an isomorphism. That's fine -- a SkgNode might or might not have something to say about any of its optional lists. That's why there exists code (reconcile_dup_instructions and clobber_none_fields_with_data_from_disk) for joining what multiple SkgNodes have to say about a field.
** DONE move extra_ids_from_pid to rust/test-utils.rs
** document in comments
*** three saveinstructions per merge
    a merge produces three SaveInstructions:
      create, update, delete
    rather than just updating two nodes.
*** justify these rules
**** Acquiree as replaced → DROP
**** Acquiree as hidden → DROP
*** when merge requests are processed
**** // Merge requests are handled during save, not rebuild/view
     this comment probably needs rewording
**** merge requests are ignored
     in 'complete_node_preorder',
     and thus in its (more meaningfully-named) caller
     'completeOrgnodeForest'
* complex code elsewhere
** What does 'reconcile_dup_instructions_for_one_id' do?
