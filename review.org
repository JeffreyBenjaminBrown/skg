* TODO reading history
  reading upward in the git log as shown by magit
** TODO last file completely read
   rust/rebuild.rs
* changes since main
** Add Merge(ID) constructor to NodeRequest
pub enum NodeRequest {
  ContainerwardView,
  SourcewardView,
  Merge(ID),  // Request to merge another node into this one
}
** Add 'extra_ids_from_pid' in typedb::search
   +pub async fn extra_ids_from_pid(
   +  db_name: &str,
   +  driver: &TypeDBDriver,
   +  node_id: &ID,
   +) -> Result<Vec<ID>, Box<dyn Error>> {
** the merge algorithm
* TODO
** DONE Don't detect text!
You write that the string 'MERGED-' is used to classify nodes. That's dangerous. Instead, would it be feasible to define a struct 'Merge_3_SaveInstructions', with fields that specify which is the 'acquirer', which the 'acquiree', and which the 'preserver' (of the acquiree's text)?
*** Title Format - Changed acquiree_text_preserver title from "MERGED: " to "MERGED-" to avoid Tantivy query syntax conflicts with colons
** ONGOING The SkgNodes in the three SaveInstruction should have all the relevant information.
*** 1
Great!

Next: The information computed here:
```
    // Compute final relationship fields for acquirer
    let acquirer_final_contains : HashSet<ID> =
      updated_acquirer.contains.iter().cloned().collect();

    let mut acquirer_to_write : SkgNode = updated_acquirer.clone();

    // Combine hides_from_its_subscriptions (with filtering)
    let mut combined_hides : Vec<ID> = Vec::new();
    for list in [&updated_acquirer.hides_from_its_subscriptions,
                 &acquiree.hides_from_its_subscriptions] {
      if let Some(hides_list) = list {
        for hidden_id in hides_list {
          if !acquirer_final_contains.contains(hidden_id)
             && !combined_hides.contains(hidden_id) {
            combined_hides.push(hidden_id.clone());
          }
        }
      }
    }
    acquirer_to_write.hides_from_its_subscriptions = Some(combined_hides);

    // Combine subscribes_to
    acquirer_to_write.subscribes_to = Some(
      updated_acquirer.subscribes_to.clone().unwrap_or_default()
        .into_iter()
        .chain(acquiree.subscribes_to.clone().unwrap_or_default())
        .collect()
    );

    // Combine overrides_view_of
    acquirer_to_write.overrides_view_of = Some(
      updated_acquirer.overrides_view_of.clone().unwrap_or_default()
        .into_iter()
        .chain(acquiree.overrides_view_of.clone().unwrap_or_default())
        .collect()
    );
```
should be calculated earlier, in 'saveinstructions_from_the_merge_in_a_node'.
*** 2
Can you move the SaveInstruction-creating functions in rust/merge.rs to a new file, rust/merge/merge3saveinstructions.rs? And move the code that defines the acquirer's fields to a standalone function?
** Serialization - Updated SkgNode serialization to write Some([]) as empty arrays instead of omitting them, ensuring proper deserialization.
** document in comments
*** three saveinstructions per merge
    a merge produces three SaveInstructions:
      create, update, delete
    rather than just updating two nodes.
*** fix documented and implemented SkgNode field interpretations
    None = "This skgnode has no opinion regarding what should be there."
    Some(x) = "This skgnode believes x should be there."
*** justify these rules
**** Acquiree as replaced → DROP
**** Acquiree as hidden → DROP
*** // Merge requests are handled during save, not rebuild/view
    this comment probably needs rewording
*** merge requests are ignored in 'complete_node_preorder', and thus in its (more meaningfully-named) caller 'completeOrgnodeForest'
** extra_ids_from_pid
*** test it
*** move it to rust/test-utils.rs
** be sure this is tested
   if A is merged into B and A had a link to C,
   now the first child of B has a link to C.
* complex code elsewhere
** What does 'reconcile_dup_instructions_for_one_id' do?
** Is reconcile_dup_instructions_for_one_id called only after IDs are replaced with PIDs?
** reconcile_dup_instructions_for_one_id
   must handle the other optional lists
