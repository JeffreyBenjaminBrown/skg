#+title: BFS Rendering with Node Limit

* Executive Summary
** Goal
Introduce a configurable limit to the number of nodes rendered in initial content views (but not when saving), using BFS instead of DFS to ensure more useful partial views.

** Key Changes
1. Add =initial_node_limit= field to =SkgConfig= (default: 1000)
2. Switch from DFS to BFS for content view generation
3. When limit is hit at node N in generation G:
   - Save reference to N and its parent P
   - Go back to start of Gen G
   - Render entire Gen G as truncated (indefinitive)
   - When reaching N, complete its sibling group (also truncated)
   - Stop - don't render rest of Gen G (nodes don't exist)
   - Truncate everything after P in Gen G-1
   - Stop - don't process earlier or deeper generations

** Rationale for Simplified Algorithm
- **All Gen G nodes are truncated**: Won't have children rendered (limit hit), so must be indefinitive
- **Complete sibling group**: Users expect to see ALL siblings, even if truncated
- **Don't render after sibling group**: More efficient - those nodes simply don't exist
- **Gen G-1 nodes after parent truncated**: Won't have children rendered, so must be indefinitive
- **Earlier generations stay definitive**: Already had children rendered
- **Simpler implementation**: No tracking which nodes were already processed, single pass through Gen G

** Implementation Approach
Process generation-by-generation rather than node-by-node:
- Collect all nodes in generation G
- Check if processing them would exceed limit
- If no: process all nodes normally and move to next generation
- If yes (limit hit):
  1. Save NodeRef to the limit node
  2. Go back to start of generation G
  3. Walk through generation, rendering all nodes as truncated (indefinitive)
  4. When reaching limit node, complete its sibling group (also truncated)
  5. Stop - don't render rest of generation G
  6. Truncate everything after parent in generation G-1

This approach is simpler and more efficient than tracking which nodes to process normally vs. truncated.

** Important Clarification (commit bb476aa)
Indefinitive nodes have NO effect on saves (except for delete instructions).
This simplifies the truncation implementation - marking nodes as indefinitive is purely for display purposes.
Truncated nodes won't accidentally contribute data when saved.

* Current Architecture
** Entry Point
API request: =((request . "single root content view") (id . "NODE_ID"))=

Handler: =rust/serve/handlers/single_root_view.rs:handle_single_root_view_request=
- Calls =single_root_view= in =rust/to_org/content_view.rs=

** Current View Generation Pipeline (DFS)
=multi_root_view= in =rust/to_org/content_view.rs:40=:
1. =stub_forest_from_root_ids= - Create minimal forest with just root nodes (no children)
2. =completeOrgnodeForest= - Main completion logic (DFS traversal)
3. =set_metadata_relationship_viewdata_in_forest= - Enrich with relationship metadata
4. =render_forest_to_org= - Convert tree to org-mode text

** Current Completion Strategy (DFS)
=completeOrgnodeForest= in =rust/to_org/complete_contents.rs:24=:
- Maintains shared =visited: HashSet<ID>= across all trees in forest
- Maintains =ancestor_path: Vec<ID>= for cycle detection
- Calls =complete_node_preorder= on each tree's root

=complete_node_preorder= in =rust/to_org/complete_contents.rs:83=:
*** Processing order (preorder DFS):
1. Handle node itself:
   - =make_indefinitive_if_repeated=: Check if node's ID is in =visited=
     - If already visited: mark =indefinitive=true=, skip adding to visited
     - If not visited and node is definitive: add ID to =visited=
   - =detect_cycle_and_mark_if_so=: Check if ID is in =ancestor_path=, mark =cycle=true= if so
2. Process node's content:
   - If indefinitive: =clobberIndefinitiveOrgnode= (set title from disk, clear body, set source)
   - If definitive: =completeDefinitiveOrgnode= (read from disk, reconcile children, add missing content)
3. Recurse to all children via =map_complete_node_preorder_over_children=
4. Integrate view requests (aliases, containerward, sourceward)

*** Key behavior:
- Indefinitive nodes still have their children recursed into (for view requests)
- But indefinitive nodes don't expand new content children from disk
- Only definitive nodes call =extend_content= to add missing children

** Indefinitive Nodes
From =rust/types/orgnode.rs:51= (updated in commit bb476aa):
#+begin_quote
Describes a node's relationship to those of its children that are content.
A definitive node defines the title, body and initial contents, if present.
So changing which nodes are its children can change its contents.
Indefinitive nodes, by contrast, do not permit the user to modify the node they represent.
If it has children, they are kept in the view when the user saves,
but saving does not create a 'contains' relationship from the indefinitive parent to the child.
#+end_quote

From =rust/types/save.rs= (updated in commit bb476aa):
#+begin_quote
An indefinitive node generally has no effect on the graph when saved.
The exception is that it can contain a delete instruction.
#+end_quote

Currently used for:
- Repeated nodes (already seen in =visited= set)
- Nodes marked indefinitive by user (rare)

Will be extended for:
- Nodes beyond the rendering limit (truncated nodes)

* New Architecture Requirements
** New SkgConfig Field
Add to =rust/types/misc.rs:45= in =SkgConfig= struct:
#+begin_src rust
#[serde(default = "default_initial_node_limit")]
pub initial_node_limit : usize,  // Max nodes to render in initial views
#+end_src

Add default function:
#+begin_src rust
fn default_initial_node_limit() -> usize { 1000 }
#+end_src

** BFS Traversal Strategy
*** Why BFS instead of DFS?
- DFS could render the entire left branch of a tree before any right branches
- With a limit, this creates a very skewed, less useful view
- BFS renders all siblings at each depth before going deeper
- Provides a more balanced, useful partial view

*** Tree Utilities Available
=rust/media/tree.rs= provides BFS iteration utilities:
- =first_in_generation_in_forest(forest, generation)= - Get first node at depth N
- =next_in_generation_in_forest(forest, tree_index, node)= - Get next node at same depth
- These handle cross-tree iteration in forests

*** BFS Traversal Pattern
#+begin_src rust
let mut generation: usize = 1;
let mut nodes_rendered: usize = 0;

loop {
  // Get first node in this generation
  let mut node_opt = first_in_generation_in_forest(forest, generation)?;
  if node_opt.is_none() { break; } // No more generations

  let mut tree_index: usize = 0;

  while let Some(node) = node_opt {
    // Process node
    nodes_rendered += 1;

    if nodes_rendered > config.initial_node_limit {
      // Start truncation
    }

    // Get next node in this generation
    node_opt = next_in_generation_in_forest(forest, tree_index, node);
  }

  generation += 1;
}
#+end_src

** Truncation Strategy
When =nodes_rendered >= initial_node_limit=:

*** Simplified Algorithm
When limit is hit at node N in generation G (where N's parent is P):

**Step 1**: Save reference to limit node
- Save NodeRef to N ("where-limit-was-hit")
- Save N's parent P

**Step 2**: Render entire generation G as truncated
- Go back to start of generation G
- Walk through generation, rendering each node as truncated (indefinitive)
- When reaching N (where limit was hit):
  - Continue rendering N's remaining siblings (also truncated)
  - After completing N's sibling group, STOP
- Nodes after N's sibling group are NOT rendered (don't exist in tree)
- Rationale: Users expect to see ALL siblings for completeness, but not unrelated nodes

**Step 3**: Truncate parent's generation
- Go up to N's parent P (in generation G-1)
- Truncate everything in generation G-1 that comes AFTER P
  - Not just P's immediate siblings
  - But ALL remaining nodes in that generation (across all trees)

**STOP**: Don't process further
- Do NOT continue recursing up the tree to G-2, G-3, etc.
  - Those nodes have already had their children rendered, so they can remain definitive
- Do NOT process generation G+1 or deeper
  - Those nodes simply won't exist in the tree

*** Example 1: Simple Case
#+begin_example
Tree structure:
A
  A1
  A2
    A21
    A22 <- hit limit here
    A23
  A3
B
  B1
  B2

BFS generations:
- Gen 1: A, B
- Gen 2: A1, A2, A3, B1, B2
- Gen 3: A21, A22, A23

If limit is reached at A22:

Step 0: Complete A22's sibling group
- A22's siblings: A21, A22, A23
- Continue rendering A23 (even though we're over limit)
- Mark A23 as indefinitive
- Result: All of [A21, A22, A23] are rendered (but truncated)

Part 1: Truncate ENTIRE Gen 3
- Mark as indefinitive: A21, A22, A23

Part 2: Truncate everything AFTER A2 in Gen 2
- A2's subsequent nodes in Gen 2: A3, B1, B2
- Mark as indefinitive: A3, B1, B2

Part 3: Don't render Gen 4
- No nodes in Gen 4 are created or rendered

STOP - Don't go to Gen 1
- A and B remain definitive (they already had their children rendered)

Total rendered but truncated (indefinitive): [A21, A22, A23, A3, B1, B2]
Remain definitive: [A, B, A1, A2]
#+end_example

*** Example 2: Multiple Sibling Groups in Same Generation
#+begin_example
Tree structure:
A
  A1
    A11
    A12
  A2
    A21
    A22 <- hit limit here
    A23
  A3
B
  B1

BFS generations:
- Gen 1: A, B
- Gen 2: A1, A2, A3, B1
- Gen 3: A11, A12, A21, A22, A23

If limit is reached at A22 (4th node in Gen 3):

Algorithm:
1. Save NodeRef to A22 (where limit was hit)
2. Save A22's parent (A2)
3. Go back to start of Gen 3
4. Walk through Gen 3, rendering as truncated:
   - Render A11 (truncated/indefinitive)
   - Render A12 (truncated/indefinitive)
   - Render A21 (truncated/indefinitive)
   - Render A22 (truncated/indefinitive) - reached limit node
   - Render A23 (truncated/indefinitive) - same parent as A22, complete sibling group
5. STOP - Don't render rest of Gen 3
   - A11, A12, A21, A22, A23 are rendered (all truncated)
   - NO other nodes in Gen 3 exist in the tree
6. Truncate everything after A2 in Gen 2:
   - Mark A3, B1 as indefinitive

Result:
- Rendered and truncated (indefinitive): A11, A12, A21, A22, A23, A3, B1
- Remain definitive: A, B, A1, A2
- Not rendered at all: (nothing after A23 in Gen 3)
- Gen 4 and deeper: Not rendered at all
#+end_example

*** Rationale and Benefits
**Why render entire generation G as truncated?**
- All nodes in Gen G won't have their children rendered (limit hit)
- Therefore they must all be shown as truncated (indefinitive)
- Simpler than tracking which nodes were already processed normally

**Why complete the sibling group?**
- Users expect to see ALL siblings for completeness
- Seeing "A has children: A1, A2 (indef), A3 (indef)" is better than "A has children: A1, A2 (indef), ???"
- But we don't need to render unrelated sibling groups (more efficient)

**Why truncate after parent in Gen G-1?**
- Those nodes won't have their children rendered either
- Must be shown as truncated

**Why stop at Gen G-2?**
- Earlier generations already had their children rendered
- Can remain definitive

**Efficiency gains:**
- Don't render nodes after limit sibling group (they simply don't exist)
- Don't need complex logic to track which nodes to process normally vs. truncated
- Single pass through Gen G (no need to go back and retroactively mark nodes)

*** Interaction with Repetition
- Repeated nodes are already marked indefinitive
- For repeated nodes, truncation doesn't change anything
- But we should still count them toward the limit

* Implementation Challenges and Questions
** Challenge 1: Tree Utilities Need Mutable Access
The tree utilities in =rust/media/tree.rs= currently use immutable =NodeRef=.
For this feature, we need mutable access to mark nodes as indefinitive and add children.

*** Solution: Modify Tree Utilities
Update the tree utilities to use mutable =NodeMut= instead of immutable =NodeRef=.

** Challenge 2: Initial View Generation vs Buffer Completion
Saved buffer "completion" (=completeOrgnodeForest=) is complex due to sourceward/containerward view overlap.

For initial view generation (de novo), it's much simpler: just render the node's contents in order.

*** Solution: Create New BFS Rendering Function
Don't call =completeOrgnodeForest= for initial view generation. Instead, create new simpler logic:
- Read node from graph database
- Get its content children (from =contains= relationship only - no sourceward/containerward)
- Add them to the tree in BFS order
- Not "completion" - just "rendering initial content"

This is cleaner and more appropriate for initial view generation.

** Challenge 3: Save Path - No Changes Needed
The =initial_node_limit= applies only to initial view generation, not saves.

Save path uses =completeOrgnodeForest= (which we're NOT modifying):
- Initial view: Use new BFS rendering function (with limit)
- Save: Continue using =completeOrgnodeForest= (no limit)

Both paths share these functions (no changes needed):
- =set_metadata_relationship_viewdata_in_forest= - Adds metadata, doesn't change forest shape
- =render_forest_to_org= - Immutable, just converts to text

Verified: These shared functions don't add/remove nodes (don't change forest shape), so no need for save process to be aware of node limit.

* Proposed Implementation Plan
** Phase 1: Add Configuration
1. Add =initial_node_limit= field to =SkgConfig= in =rust/types/misc.rs=
2. Add =default_initial_node_limit()= helper function
3. Test that config loads correctly with and without the field

** Phase 2: Implement BFS Rendering (Without Limit)
Create new initial view generation logic using BFS:

1. Create new function for initial view generation (not reusing save buffer completion logic)
2. Implement generation-by-generation processing:
   - For each generation:
     - Collect all NodeIds at that generation using tree utilities
     - For each node in generation (in BFS order):
       - Check if repeated (using visited set)
       - If not repeated: render it (read from graph, get =contains= children, add to tree)
       - If repeated: mark as indefinitive
     - Children added during this generation become next generation
3. Maintain =visited= set to detect repetitions
4. Update tree utilities in =rust/media/tree.rs= to use mutable refs
5. Test that BFS rendering works correctly

*** Generation-by-Generation Processing Pattern
#+begin_src rust
let mut generation: usize = 1;
let mut visited: HashSet<ID> = HashSet::new();

loop {
  // Collect all NodeIds in this generation
  let nodes_in_gen: Vec<(usize, NodeId)> = // (tree_index, node_id) pairs
    collect_generation(forest, generation)?;

  if nodes_in_gen.is_empty() { break; } // No more generations

  // Process each node in this generation
  for (tree_idx, node_id) in nodes_in_gen {
    // Check repetition, complete if definitive, etc.
    process_node(forest, tree_idx, node_id, &mut visited)?;
  }

  generation += 1;
}
#+end_src

** Phase 3: Add Node Counting
1. Thread =nodes_rendered: usize= counter through BFS logic
2. Increment for each node processed
3. Log when limit would be reached (but don't truncate yet)
4. Test that counting is accurate

** Phase 4: Implement Truncation
With generation-by-generation processing, truncation becomes cleaner:

*** Truncation Algorithm (Simplified)
#+begin_src rust
let mut generation: usize = 1;
let mut visited: HashSet<ID> = HashSet::new();
let mut nodes_rendered: usize = 0;
let limit: usize = config.initial_node_limit;

loop {
  // Collect all NodeIds in this generation
  let nodes_in_gen: Vec<(usize, NodeId, Option<NodeId>)> =
    // (tree_index, node_id, parent_id)
    collect_generation_with_parents(forest, generation)?;

  if nodes_in_gen.is_empty() { break; }

  // Check if this generation would exceed the limit
  if nodes_rendered + nodes_in_gen.len() > limit {
    // LIMIT HIT!
    let overflow_index: usize = limit - nodes_rendered;
    let where_limit_was_hit: NodeId = nodes_in_gen[overflow_index].1;
    let limit_parent: Option<NodeId> = nodes_in_gen[overflow_index].2;

    // Go back to start of this generation
    // Render everything as truncated (indefinitive)
    let mut hit_limit_node = false;
    for (tree_idx, node_id, parent) in nodes_in_gen {
      // Render node as truncated
      process_node_as_truncated(
        forest, tree_idx, node_id, &mut visited)?;

      // Check if we've reached the limit node
      if node_id == where_limit_was_hit {
        hit_limit_node = true;
      }

      // If we've passed the limit node and moved to a different parent,
      // stop (don't render rest of generation)
      if hit_limit_node && parent != limit_parent {
        break;
      }
    }

    // Apply truncation to parent's generation
    apply_truncation_to_parent_generation(
      forest,
      generation,
      where_limit_was_hit)?;

    // Stop processing further generations
    break;
  }

  // Under limit - process all nodes in this generation normally
  for (tree_idx, node_id, _parent) in nodes_in_gen {
    process_node(forest, tree_idx, node_id, &mut visited)?;
    nodes_rendered += 1;
  }

  generation += 1;
}
#+end_src

*** Truncation Helper Functions
#+begin_src rust
fn process_node_as_truncated(
  forest: &mut Vec<Tree<OrgNode>>,
  tree_idx: usize,
  node_id: NodeId,
  visited: &mut HashSet<ID>,
) -> Result<(), Box<dyn Error>> {
  // Mark node as indefinitive
  mark_indefinitive(forest, tree_idx, node_id)?;

  // Update visited set if node has an ID
  let node_pid_opt: Option<ID> =
    get_node_id(forest, tree_idx, node_id)?;
  if let Some(pid) = node_pid_opt {
    visited.insert(pid);
  }

  Ok(())
}

fn apply_truncation_to_parent_generation(
  forest: &mut Vec<Tree<OrgNode>>,
  limit_generation: usize,
  limit_node_id: NodeId,
) -> Result<(), Box<dyn Error>> {
  // Find parent of limit node
  let limit_parent: Option<NodeId> =
    find_parent(forest, limit_node_id)?;

  if let Some(parent_id) = limit_parent {
    let parent_gen: usize = limit_generation - 1;

    // Truncate everything after parent in parent's generation
    truncate_after_in_generation(
      forest,
      parent_gen,
      parent_id)?;
  }

  Ok(())
}

fn truncate_after_in_generation(
  forest: &mut Vec<Tree<OrgNode>>,
  generation: usize,
  after_this_node: NodeId,
) -> Result<(), Box<dyn Error>> {
  // Collect all nodes in this generation
  let nodes_in_gen: Vec<(usize, NodeId)> =
    collect_generation(forest, generation)?;

  // Find the position of after_this_node
  let mut found = false;
  for (tree_idx, node_id) in nodes_in_gen {
    if found {
      // Everything after the target node gets truncated
      mark_indefinitive(forest, tree_idx, node_id)?;
    }
    if node_id == after_this_node {
      found = true;
    }
  }

  Ok(())
}
#+end_src

*** Testing
1. Test with various tree structures (single tree, forest)
2. Test where limit hits at different depths (Gen 1, 2, 3, etc.)
3. Test with multiple sibling groups in same generation
4. Test truncation of "everything after parent" in parent's generation
5. Verify earlier generations remain definitive (children already rendered)
6. **Test sibling group completion**:
   - Limit hit at first node in sibling group (all siblings rendered as indefinitive)
   - Limit hit at middle node in sibling group (all siblings rendered, later ones indefinitive)
   - Limit hit at last node in sibling group (all siblings rendered normally)
7. Test edge cases:
   - Limit hit at first node in generation
   - Limit hit at last node in generation
   - Parent is last node in its generation (nothing to truncate after it)
   - Limit hit in Gen 1 (roots)
   - Sibling group that spans the limit boundary

** Phase 5: Handle Edge Cases
1. Repeated nodes near limit
2. Limit reached in middle of sibling group
3. Small limits (limit=1 should show all roots as truncated)
4. Limit hit in Gen 1 (roots)
5. Sibling group that spans the limit boundary

** Phase 6: Integration
1. Update =single_root_view= and =multi_root_view= in =rust/to_org/content_view.rs=:
   - Replace =completeOrgnodeForest= call with new BFS rendering function
   - Keep =set_metadata_relationship_viewdata_in_forest= and =render_forest_to_org= as-is
2. Save buffer path (=update_from_and_rerender_buffer=) continues using =completeOrgnodeForest= unchanged
3. Run full test suite
4. Integration tests with real data

* Edge Cases and Special Behaviors
** Small Limits
Node limit must be a positive integer (>= 1).

Example: limit=1 with 10 root nodes:
- We render the entire first generation (all 10 roots)
- But render them as truncated: indefinitive, no children, no body, just title and metadata
- This is consistent with the general behavior: when limit is hit, render that whole generation through end of sibling group
- For roots, the "sibling group" is all the roots (they share the same implicit parent)

* Implementation Notes
** Existing Code to Reuse
- =make_indefinitive_if_repeated= - Can reuse for marking truncated nodes
- =clobberIndefinitiveOrgnode= - Already handles indefinitive nodes correctly
- =completeDefinitiveOrgnode= - Can reuse for definitive nodes in BFS
- Tree utilities in =rust/media/tree.rs= - For BFS iteration pattern

** Existing Code to Modify
- =completeOrgnodeForest= - Main refactoring target
- =complete_node_preorder= - Will be replaced by BFS logic
- =map_complete_node_preorder_over_children= - Will be replaced

** Testing Strategy
1. Unit tests for BFS traversal order
2. Tests for node counting accuracy
3. Tests for truncation with various tree shapes
4. Integration tests with real .skg data
5. Comparison tests: DFS vs BFS output (should be same except ordering)
6. Edge case tests: cycles, repeated nodes, view requests, very small limits
