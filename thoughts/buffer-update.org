* rewriting how buffer update works
** relevant prior art
*** the old completion functions
    Search for functions with 'integrate' or 'complete' in the name
    to see how some of these ideas have been implemented,
    albeit likely in a less principled way, already.
*** the code under server/update_buffer/
*** the utilities under server::types::tree::
** how buffer update currently works
A call graph can be found at
tools/introspect/call-graph/output/update_from_and_rerender_buffer.org
*** skgnode_map : SkgNodeMap
    PITFALL: incomplete, so don't read from it directly;
    instead use skgnode_from_map_or_disk,
    which reads from disk and updates it when a key is empty.
*** source_diffs : Option<HashMap<SourceName, SourceDiff>>
    only for git-diff view
*** deleted_id_src_map : HashMap<ID, SourceName>
*** complete_or_restore_each_node_in_branch
**** allow indef nodes to be missing content
     don't complete their content
**** correct the aliasCol in an indef node
     It can't be wrong in a def node,
     so it doesn't need correcting there.
**** correct the SubscribeeCol in an indef node
     It can't be wrong in a def node
     so it doesn't need correcting there.
**** detect_and_mark_cycle
**** make_indef_if_repeat_then_extend_defmap
**** clobberIndefinitiveOrgnode
**** maybe_add_subscribeeCol_branch
*** view_requests : Vec < (NodeId, ViewRequest) >
    Was just for speed.
    Should instead interleave with other completion ops,
    but for each node perform view requests last,
    so that they can be integrated with overlapping content.
*** set_metadata_relationship_viewdata_in_forest
** how to redo buffer update
*** notes and complications
**** Contra previously, we correct aliases and other 'regenerables'.
     As the code courrently stands, regenerating them.
     See the function remove_regenerable_scaffolds.
**** Some viewnodes only need completion if their parent is indef.
     Namely AliasCol, SubscribeeCol, and IDCol.
     If their parent is definitive,
     then they just defined the truth,
     so they don't need to be adjusted toward it.
     (But completion should proceed within their children.)
*** DONE write these functions
**** completeAliasCol
     Take a treenode, a tree and a skgnodemap.
     Verify that the node is an AliasCol.
     Visits its parent, verifies it's a truenode,
     fetch the corresponding skgnode from the map,
     and reads the aliases into a variable
     'aliases' (a list of strings).
     'Complete' the AliasCol's children against 'aliases':

     First partition the AliasCol's children into two sets:
     truenodes with parentIgnores, and Alias nodes.
       (If anything does not fit those two categories,
       throw an error to the caller.)
     Put all the ignored truenodes first.
     Among the aliases, discard any whose text is not in 'aliases'.
     Create a new Alias node for each value in 'aliases'
     not found among the Alias treenodes.
     Add those new Alias treenodes to its Alias children,
     such that the resulting list of Alias children
     is equal to 'aliases', and in the same order.
**** complete_relevant_children
**** partition_children
**** subtree_has_focus
**** move_child_to_end
*** do these, in serial
**** DFS preorder (parent-first) completion
***** DONE TrueNode
****** apply make_indef_if_repeat_then_extend_defmap to it
****** if it's definitive
******* reorder children and complete content
        Ensure its non-ignored truenode children are,
        and in order, equal to its contents.
        Do this by running complete_relevant_children
        on its content (from the skgnode)
        and its children (from the viewnode tree).

        Reorder children to be non-truenodes,
        then parentIgnored truenodes, then content truenodes.
        Use partition_children for this.

        If in git diff view, insert phantom nodes
        (this is already implemented somewhere)
        into the source of truth for the content list.
******* mark its erroneous content children as parent-ignores
        'erroneous content children' are truenode children
        not marked parentIgnores but not among its content.
        Use its skgnode (not its viewnode) to determine its content.
        Use 'treat_certain_children' and 'skgnode_for_viewnode'.
******* if a SubscribeeCol is needed and absent, prepend one as a child
        It is needed if the associated skgnode subscribes to anything.
        Don't populate the SubscribeCol with grandchildren
        -- that will happen when processing visits the SubscribeCol.
******* if a TextChanged is needed and absent, prepend one as a child
        This is only needed in the git diff view.
******* if an IDCol is needed and absent, prepend one as a child
        This is only needed in the git diff view.
******* If an AliasCol is needed and absent, prepend it as a child.
        It is only needed in the git diff view.
****** if it's indefinitive
       Run clobberIndefinitiveOrgnode on it.
***** TODO SubscribeeCol
****** If its parent has no subscribees
       Then delete this subscribeecol from the tree,
       along with its entire recursive content.
       Before deleting, first check whether anything in it
       has focus, and if so transfer focus to its parent
       (the nearest surviving ancestor).
       For the focus logic, mimic
         complete_relevant_children_in_viewnodetree.
       Don't look for focus if it won't be deleted.
****** If its parent has subscribees
       If the parent is indefinitive:
         Use complete_relevant_children to ensure that
         this subscribeecol's nonignored truenode children
         are exactly the parent's subscribees.
         A child is relevant if it is a nonignored truenode.
         The goal list should be those subscribees.
         The child creation function should be
           mk_indefinitive_viewnode.
       Regardless of whether the parent is definitive,
         move the HiddenOutsideOfSubscribeeCol (it should be unique)
         to be the last child, or append one if there is none.
         Do not populate the HiddenOutsideOfSubscribeeCol
         with (from the SubscribeeCol's point of view) grandchildren.
         (The HiddenOutsideOfSubscribeeCol will be visitied soon,
         and will be processed from there, rather than from here.)
**** DFS postorder (child-first) completion
***** DONE nothing to do : forestroot
***** DONE alias col
      read your parent, and then
      order and complete its aliases among your children
***** DONE nothing to do : alias
      but add a comment: for its own correctness, an alias must
        rely on its parent's having been processed correctly
***** DONE nothing to do : TextChanged
      but add a comment: for its own correctness, a TextChanged
        relies on its parent's having been processed correctly
***** DONE nothing to do : ID
      but add a comment: For correctness, an ID relies on
        its parent having been handled correctly.
***** IDCol
      Ensure that your children are only, and in order,
        the IDs of your parent,
        or (in the git diff view) the difflist associated with it.
***** HiddenInSubscribeeCol
      Read the col's ancestor 1 (Subscribee) and 3 (Subscriber),
      find everything subscriber hides that subscribee contains,
      and ensure your children are only those, and in order.
      Mark anything else 'parentIgnores'.
      If you have no children, remove yourself.
***** HiddenOutsideOfSubscribeeCol
      Read your siblings (subscribees) and parent (subscriber).
      Ensure that your children are, and in order,
        only what the subscriber hides that no subscribee contains.
      If you have no children, remove yourself.
***** SubscribeeCol
      read your parent, and then
      - ensure your non-ignored truenode children
        include all of its subscribees
      - mark any other truenode children 'parentIgnores',
        and move them to before the subscribees
      - append, after all the others, a HiddenOutsideOfSubscribeeCol
        (which will be removed if it would be childless).
        TRICKY: The HiddenOutsideOfSubscribeeCol
        must be processed after all the subscribees,
        so it can determine what they have already excluded.
        DFS postorder (children first) traversal ensures this.
***** TrueNode
      Process view requests.
      TRICKY: Best to do this once its content is recursively complete.
      The earlier preorder completion gives it all its children.
      This gives the view request maximum opportunity
      to use some of that content rather than create new content.
**** compute GraphNodeStats
     the function is currently called
       set_metadata_relationship_viewdata_in_forest
     but should be renamed
       set_graphnodestats_in_forest
**** compute ViewNodeStats
     This currently happens in at least two places.
       detect_and_mark_cycle is one of them.
     They should be collected into a single function,
       set_viewnodestats_in_forest
***** detect_and_mark_cycle
***** somewhere else
** cleanup
*** Isn't there already something like subtree_has_focus?
