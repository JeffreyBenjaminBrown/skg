#+title: Node Limit Implementation Plan

* Current Architecture

** Content View Generation Flow:
1. Entry point: =single_root_view= → =multi_root_view= → =forest_from_root_ids=
2. Tree building: =orgnode_tree_from_id_with_earlier_visits= creates initial tree
3. Recursive traversal: =build_orgnode_tree_recursive= performs DFS, recursing into ALL children from =skgnode.contains= (lines 117-128, 167-178 of content_view.rs)
4. Completion: Later, =completeOrgnodeForest= (in rebuild) distinguishes content vs non-content via =categorize_children_by_treatment= checking =relToParent == Content=
5. Rendering: =render_forest_to_org= skips children only for =repeat= nodes (line 387)

** Key Observation
Currently, initial tree building doesn't distinguish content from non-content children - that happens later during completion.

* Implementation Plan

** 1. Add =truncated= field to metadata (OrgnodeCode)
- Location: =rust/types/orgnode.rs=, line 56
- Type: =pub truncated: bool=
- Position: After =indefinitive=, before =editRequest= (as specified)
- Default: =false=

** 2. Update metadata serialization/parsing
*** In =orgnodemd_to_string= (=rust/serve/parse_headline_md_sexp.rs=, ~line 99):
#+begin_src rust
if metadata.code.truncated {
  code_parts.push ( "truncated".to_string () ); }
#+end_src

*** In =parse_code_sexp= (~line 313):
#+begin_src rust
"truncated" => code.truncated = true,
#+end_src

** 3. Modify tree building to track node count
- Add =node_count: &mut usize= parameter to =build_orgnode_tree_recursive=
- Add =node_limit: Option<usize>= parameter (passed from config or API request)
- Increment counter when adding each node
- Before recursing, check: should we recurse based on limit and relationship type?

** 4. Implement selective recursion logic
*** Challenge
At tree-building time (in =to_org/content_view.rs=), we only have =skgnode.contains= - we don't yet know which children are Content vs others

*** Two possible approaches:

**** A) Early relationship detection
Query the child's =relToParent= from disk before deciding to recurse

**** B) Defer limit enforcement
Build full tree, then prune during completion phase

*** Recommendation
I'm inclined toward approach A because it's more efficient (doesn't build what we'll discard), but it requires reading each child's metadata earlier.

** 5. Mark truncated nodes
When we decide NOT to recurse into a content child due to limit:
- Still add the child node to the tree
- Set =child_orgnode.metadata.code.truncated = true=
- Set =child_orgnode.metadata.code.indefinitive = true= (since we're not showing its full content)
- Don't recurse into its children

** 6. Update rendering
In =render_forest_to_org= (~line 387), skip recursion for truncated nodes:
#+begin_src rust
if ! node.metadata.viewData.repeat && ! node.metadata.code.truncated {
  for child in node_ref.children() { ... }
}
#+end_src

** 7. Passing the limit through the API
- Add optional =node_limit= field to SkgConfig or as API parameter
- Thread through =single_root_view= → tree building functions

* Questions & Ambiguities

** 1. How to distinguish content children during tree building?
- Currently =build_orgnode_tree_recursive= just reads =skgnode.contains= (all children together)
- Do we need to read each child's file to check its =relToParent=? Or can we store this relationship info in TypeDB?
- Suggestion: Add a TypeDB query to check if a contains-relationship has the Content type, since this info might already be there

** 2. What about non-content children that HAVE content children?
- Example: Node A has aliasCol child AC, which has alias children
- Should we count aliases toward the limit, or only Content children?
- Interpretation: We always recurse into non-content, so aliases wouldn't count toward limit

** 3. Limit scope: per-tree or across forest?
- Should the counter be shared across all trees in a =multi_root_view=, or separate per tree?
- Assumption: Per-forest (shared counter) makes more sense for UI purposes

** 4. Truncated nodes and body text:
- Should truncated nodes show their body, or replace it like repeated nodes do?
- Suggestion: Show original body (unlike repeated nodes which say "Repeated, probably above")

** 5. Where in the tree building does the limit apply?
- Only during initial =build_orgnode_tree_recursive=, or also during =completeContents=?
- Assumption: Both places need checks, since =completeContents= adds missing children from disk
