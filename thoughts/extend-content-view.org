* Extend Content View - Implementation Plan

** Fixes That Should Precede Implementation

*** ViewRequest Clearing Bug

**** The Bug
ViewRequests are currently serialized back into buffer metadata after processing. This is incorrect - they should be ephemeral, consumed during view generation, and cleared before rendering the response.

Currently in =complete_node_preorder= (complete_contents.rs:130-150):
- ViewRequests are processed (Aliases, Containerward, Sourceward integrated into tree)
- But the =viewRequests= HashSet is never cleared
- When =orgnodemd_to_string= serializes metadata, viewRequests are written back to buffer

**** The Fix
In =complete_node_preorder=, after processing all viewRequests (line 150), clear them:

#+begin_src rust
// After the viewRequests processing loop (line 150):
{ // Clear viewRequests after processing
  let mut node_mut: NodeMut<OrgNode> =
    tree.get_mut(node_id)
    .ok_or("Node not found")?;
  node_mut.value().metadata.code.viewRequests.clear();
}
#+end_src

This ensures all viewRequests (existing and new Extend) are ephemeral.

** Feature Overview

Allow nodes in the save buffer to request content expansion from the database. The server expands that node's contents using a fresh count (starting from 0) toward the same node limit. The expansion is purely a view operation - it happens after save and only affects the response.

** Key Behaviors

1. Nodes can have Extend view requests (ephemeral, consumed during view processing)
2. Each expansion uses the same node limit (e.g., 1000) but starts counting from 0
3. Multiple Extend requests allowed per buffer
4. At most ONE Extend request per ID (validation required)
5. Each ID can appear definitively only once in the response
6. All viewRequests are cleared after processing (via bug fix above)

** Architecture

*** Metadata Representation

The Extend request is stored in the existing =viewRequests= field:

#+begin_src rust
// In OrgnodeCode (already exists):
pub viewRequests: HashSet<ViewRequest>

// Add new variant to ViewRequest enum:
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ViewRequest {
  Aliases,
  Containerward,
  Sourceward,
  Extend,  // NEW
}
#+end_src

Parse from org metadata:
#+begin_src
(code (viewRequests extend))
#+end_src

*** Save Buffer Flow

1. Parse buffer text -> =Vec<Tree<OrgNode>>=
2. Add missing info (PIDs, sources)
3. Validate (including Extend validation)
4. Convert to save instructions
5. Validate foreign nodes
6. Reconcile instructions
7. Execute save
8. **Complete orgnode forest** (collect Extend requests + visited map here)
9. **Process Extend requests** (mark existing instances indefinitive, expand content)
10. Generate response from expanded forest (viewRequests already cleared)

*** The Definitive Uniqueness Algorithm

Ensures each ID appears definitively at most once.

**** During =completeOrgnodeForest= (collection phase):

Collect two pieces of data:

1. =visited: HashMap<ID, NodeId>= - Maps each ID to the NodeId of its definitive instance
   - Add a node to =visited= if it is *definitive*, whether or not it has an Extend request
   - Do NOT add indefinitive nodes to =visited= (even if they have Extend requests)

2. =expansion_requests: Vec<(ID, NodeId)>= - Nodes that have Extend requests
   - Add ALL nodes with Extend requests (definitive or indefinitive)
   - Collected in DFS order

Return =(expansion_requests, visited)=

**** After =completeOrgnodeForest= returns (processing phase):

1. **Mark conflicting definitive instances indefinitive:**
   - For each =(id, requesting_node_id)= in =expansion_requests=:
     - Look up =id= in =visited=
     - If found with =existing_node_id= where =existing_node_id != requesting_node_id=:
       - Mark the node at =existing_node_id= as indefinitive
     - (If not found, or if found with same NodeId, do nothing)

2. **Add expansion request nodes to visited:**
   - For each =(id, requesting_node_id)= in =expansion_requests=:
     - Insert into =visited=: =visited.insert(id, requesting_node_id)=
     - This may overwrite previous values (which is fine - we already marked them indefinitive)

3. **Process each expansion:**
   - For each =(id, requesting_node_id)= in =expansion_requests=:
     - Fetch content tree using BFS with fresh count (0 to limit)
     - For each node in fetched expansion:
       - If its ID is in =visited=: mark as indefinitive
       - Otherwise: mark definitive, add to =visited=
     - Attach expansion as children of requesting node

**** Why this works:

- **Definitive node with Extend request:** Added to both =visited= and =expansion_requests=. When processing, we find it in =visited= with matching NodeId, so we don't mark it indefinitive. It gets expanded.

- **Indefinitive node with Extend request:** Added only to =expansion_requests=. When processing, either not found in =visited= (no conflict), or found with different NodeId (conflict - we mark the other one indefinitive). Then we add it to =visited= and expand it, making it definitive in the response.

- **Other definitive instance of same ID:** If there's a definitive node elsewhere with the same ID as an expansion request, we mark it indefinitive before doing the expansion, ensuring uniqueness.

** Implementation Components

*** 1. Type Definitions

**** =types/orgnode.rs=
#+begin_src rust
// Add to ViewRequest enum:
Extend,
#+end_src

**** =types/orgnode.rs= (FromStr/Display implementations)
#+begin_src rust
// In Display implementation:
ViewRequest::Extend => write!(f, "extend"),

// In FromStr implementation:
"extend" => Ok(ViewRequest::Extend),
#+end_src

**** =types/errors.rs=
#+begin_src rust
MultipleExtendRequests(ID),
#+end_src

*** 2. Validation

**** =buffer_to_orgnodes/validate_tree.rs=

New function: =validate_extend_requests=
- Collect all nodes with Extend request
- Group by ID
- Error if any ID has multiple Extend requests

Add to =validate_forest=:
#+begin_src rust
validate_extend_requests(&trees, &mut errors)?;
#+end_src

*** 3. ViewRequest Clearing (Bug Fix)

**** =to_org/complete_contents.rs=

In =complete_node_preorder=, after processing viewRequests (currently line 150), add:

#+begin_src rust
{ // Clear viewRequests after processing
  let mut node_mut: NodeMut<OrgNode> =
    tree.get_mut(node_id)
    .ok_or("Node not found")?;
  node_mut.value().metadata.code.viewRequests.clear();
}
#+end_src

*** 4. Modified completeOrgnodeForest

**** =to_org/complete_contents.rs=

Change signature to return collected data:

#+begin_src rust
pub async fn completeOrgnodeForest(
  forest        : &mut Vec<Tree<OrgNode>>,
  config        : &SkgConfig,
  typedb_driver : &TypeDBDriver,
  errors        : &mut Vec<String>,
) -> Result<(Vec<(ID, NodeId)>, HashMap<ID, NodeId>), Box<dyn Error>>
#+end_src

Modifications:
1. Change =visited= from =HashSet<ID>= to =HashMap<ID, NodeId>=
2. Add =expansion_requests: Vec<(ID, NodeId)>= to collect Extend requests
3. Pass mutable refs to both through =complete_node_preorder=
4. Populate =expansion_requests= when processing ANY node with =ViewRequest::Extend= (definitive or indefinitive)
5. Return =(expansion_requests, visited)= (do NOT add expansion requests to visited here)

**** =to_org/complete_contents.rs= - Helper modifications

Modify =complete_node_preorder= to:
- Accept =expansion_requests: &mut Vec<(ID, NodeId)>= parameter
- After checking for existing viewRequests, if node has =ViewRequest::Extend=:
  - Collect =(node.metadata.id.unwrap(), node_id)= into =expansion_requests=
- Pass =expansion_requests= through to recursive calls

Modify =make_indefinitive_if_repeated= to:
- Accept =visited: &mut HashMap<ID, NodeId>= (was =HashSet<ID>=)
- When marking node definitive, insert =(ID, NodeId)= into map (was just =ID=)
- Check/lookup uses =.contains_key()= and =.get()= instead of =.contains()=

*** 5. Content Expansion Module

**** =to_org/extend_content_views.rs= (NEW FILE)

Main entry point:
#+begin_src rust
pub async fn process_extend_requests(
  forest: &mut Vec<Tree<OrgNode>>,
  expansion_requests: Vec<(ID, NodeId)>,
  mut visited: HashMap<ID, NodeId>,
  config: &SkgConfig,
  driver: &TypeDBDriver,
) -> Result<(), Box<dyn Error>>
#+end_src

Algorithm:
1. **Mark conflicting definitive instances indefinitive:**
   - For each =(id, requesting_node_id)= in =expansion_requests=:
     - Look up =id= in =visited=
     - If =found= with =existing_node_id= where =existing_node_id != requesting_node_id=:
       - Mark node at =existing_node_id= as indefinitive

2. **Add expansion request nodes to visited:**
   - For each =(id, requesting_node_id)= in =expansion_requests=:
     - =visited.insert(id, requesting_node_id)=

3. **Process each expansion:**
   - For each =(id, requesting_node_id)= in =expansion_requests=:
     - Fetch content tree: =fetch_content_tree_bfs(id, config, driver, &visited, limit)=
     - Update =visited= map with newly definitive nodes from expansion
     - Attach expansion as children of requesting node

Supporting functions:
- =mark_node_indefinitive(forest, node_id)= - mark a specific node as indefinitive
- =fetch_content_tree_bfs(id, config, driver, visited, limit) -> Tree<OrgNode>= - BFS expansion marking nodes based on visited map
- =attach_expansion(forest, tree_idx, node_id, expansion_tree)= - attach expansion as children

*** 6. Content Fetching

**** Reuse or refactor existing BFS code

The existing code at =to_org/initial_view_bfs.rs= does BFS expansion.
We need similar logic that:
- Uses BFS with node limit (fresh count from 0)
- Marks nodes as indefinitive if ID in =visited= map
- Returns =Tree<OrgNode>= instead of modifying in place
- Can be called multiple times per save operation

This might require extracting shared BFS logic into a helper function.

*** 7. Integration

**** =serve/handlers/save_buffer.rs=

Modify =update_from_and_rerender_buffer=:

#+begin_src rust
async fn update_from_and_rerender_buffer(...) -> Result<SaveResponse, ...> {
  // ... existing code through save execution ...

  // Modified call (now returns data):
  let (expansion_requests, visited) = completeOrgnodeForest(
    &mut orgnode_forest,
    config,
    typedb_driver,
    &mut errors).await?;

  set_metadata_relationship_viewdata_in_forest(
    &mut orgnode_forest,
    config,
    typedb_driver).await?;

  // NEW: Process Extend requests
  if !expansion_requests.is_empty() {
    process_extend_requests(
      &mut orgnode_forest,
      expansion_requests,
      visited,
      config,
      typedb_driver).await?;
  }

  let buffer_content: String =
    render_forest_to_org(&orgnode_forest);

  Ok(SaveResponse { buffer_content, errors })
}
#+end_src

** Implementation Order

1. **Fix viewRequest clearing bug** (prerequisite)
   - Add =viewRequests.clear()= after processing in =complete_node_preorder=
2. Add =Extend= variant to =ViewRequest= enum
3. Add FromStr/Display implementations for =Extend=
4. Add =MultipleExtendRequests= error variant
5. Add validation for multiple Extend requests per ID
6. **Modify =completeOrgnodeForest= and helpers:**
   - Change =visited= type from =HashSet<ID>= to =HashMap<ID, NodeId>=
   - Add =expansion_requests= collection during DFS (ALL nodes with Extend, definitive or indefinitive)
   - Return =(expansion_requests, visited)= (do NOT add expansion requests to visited)
7. Implement =mark_node_indefinitive=
8. Implement =fetch_content_tree_bfs= (reuse existing BFS logic)
9. Implement =attach_expansion=
10. Implement =process_extend_requests= (with 3-phase algorithm)
11. Update =save_buffer.rs= to use new signature and call =process_extend_requests=
12. Add tests

** Edge Cases

*** Cycles
Handled by =visited= map - repeated nodes marked indefinitive.

*** Multiple Expansions
Each gets same limit but fresh count from 0. No cap on number of requests.
Example: 10 expansions with 1000 limit = up to 10,000 nodes possible.

*** Indefinitive Requesting Node
Allowed. The expansion proceeds normally regardless of requesting node's definitive status.

*** Definitive Node with Extend Request
If a node is definitive AND has an Extend request:
- It's added to both =visited= and =expansion_requests= during collection
- When processing, we look it up in =visited= and find the same NodeId
- We don't mark it indefinitive (since NodeIds match)
- We expand its content normally

*** Indefinitive Node with Extend Request
If a node is indefinitive AND has an Extend request:
- It's added to =expansion_requests= but NOT to =visited= during collection
- When processing, we either don't find it in =visited=, or find a different NodeId
- If found with different NodeId, we mark that other node indefinitive
- We add it to =visited= (now it's definitive)
- We expand its content

*** Same ID with and without Extend Request
If ID "foo" appears twice - once definitive without Extend, once indefinitive with Extend:
- Definitive instance added to =visited=: ="foo" -> nodeA_id=
- Indefinitive instance added to =expansion_requests=: =("foo", nodeB_id)=
- When processing expansion_requests, we find "foo" in =visited= with different NodeId
- We mark nodeA indefinitive, then add nodeB to =visited= (overwrites)
- Now nodeB is definitive and gets expanded

*** Source Boundaries
Expand all content regardless of source. Expansion is a VIEW operation.

*** Processing Order
- Collect requests: DFS order during =completeOrgnodeForest=
- Mark instances indefinitive: process in order collected
- Expand content: process in order collected
- BFS within each individual expansion (with node limit)

*** Conflicts
Extend + Delete: No special handling needed - Extend request is processed (view request), deletion is executed (edit request), viewRequests are cleared during processing.

** Integration Points

*** Parse Phase (=buffer_to_orgnodes.rs=)
Parse =extend= from =(code (viewRequests extend))= into =HashSet<ViewRequest>=.
This already works - just need to add the enum variant and string mappings.

*** Validation Phase (=validate_tree.rs=)
Add validation for multiple Extend requests per ID.

*** Save Phase
No changes - save happens normally before expansion.

*** View Completion Phase (=complete_contents.rs=)
Modified to:
- Track =visited= as =HashMap<ID, NodeId>= instead of =HashSet<ID>=
- Collect ALL nodes with Extend requests during DFS (definitive and indefinitive) into =expansion_requests=
- Clear viewRequests after processing (bug fix)
- Return =(expansion_requests, visited)= (do NOT add expansion requests to visited here)

*** Extend Processing Phase (NEW)
After =completeOrgnodeForest=, before =render_forest_to_org=:
Call =process_extend_requests= with 3-phase algorithm:
1. Mark conflicting definitive instances indefinitive
2. Add expansion request nodes to visited
3. Process expansions

*** Response Generation
Render to org-mode text. ViewRequests already cleared during completion phase.
