=== Implementing SubscriptionCol Using Similar Patterns to AliasCol ===

* Current AliasCol Architecture

** Structure
#+begin_example
Content Node N
└── AliasCol (relToParent = AliasCol)
    ├── Alias "foo" (relToParent = Alias)
    ├── Alias "bar" (relToParent = Alias)
    └── ...
#+end_example

** Two code paths for creating/maintaining AliasCol
1. =to_org/expand/aliases.rs::build_and_integrate_aliases= - Creates AliasCol from scratch when a =ViewRequest::Aliases= is processed. Fetches aliases from disk and populates the tree immediately.

2. =to_org/complete/aliascol.rs::completeAliasCol= - Reconciles an existing AliasCol in the tree with disk state. Called during =completeAndRestoreForest_collectingDefinitiveRequests= when an AliasCol node is encountered.

** Key patterns
- Aliases have no children - they are leaf nodes
- Alias nodes have no ID - they are identified by title
- The AliasCol has no SkgNode (=None= in the =NodePair=)
- =orgnode_from_title_and_rel= creates simple nodes with a title and RelToParent

* Proposed SubscriptionCol Structure
#+begin_example
Content Node N
└── SubscriptionCol (relToParent = SubscriptionCol)
    ├── Subscribee S1 (relToParent = Subscribee, id = S1's pid)
    │   ├── Hidden (relToParent = Hidden, title = "hidden")
    │   │   ├── H1 (relToParent = Content, id = H1's pid, indefinitive)
    │   │   └── H2 (relToParent = Content, id = H2's pid, indefinitive)
    │   └── Unintegrated (relToParent = Unintegrated, title = "unintegrated")
    │       ├── U1 (relToParent = Content, id = U1's pid, indefinitive)
    │       └── U2 (relToParent = Content, id = U2's pid, indefinitive)
    └── Subscribee S2 (relToParent = Subscribee, id = S2's pid)
        ├── Hidden ...
        └── Unintegrated ...
#+end_example

Depth: 4 generations below N (SubscriptionCol → Subscribee → Hidden/Unintegrated → Content nodes)

* Required Changes
** 1. New =RelToParent= variants (=types/orgnode.rs=)
#+begin_src rust
pub enum RelToParent {
  Content,
  AliasCol,
  Alias,
  ParentIgnores,
  // New:
  SubscriptionCol,  // Collects subscribees for its parent
  Subscribee,       // A node the grandparent subscribes to
  Hidden,           // Collects nodes hidden from subscription
  Unintegrated,     // Collects nodes not yet integrated
}
#+end_src

** 2. New =ViewRequest= variant (if needed)
If users can request subscription views via a command:
#+begin_src rust
pub enum ViewRequest {
  Aliases,
  Containerward,
  Sourceward,
  Definitive,
  // New:
  Subscriptions,
}
#+end_src

** 3. Data sources needed
From =SkgNode=:
- =subscribes_to: Option<Vec<ID>>= - list of subscribees
- =hides_from_its_subscriptions: Option<Vec<ID>>= - nodes to hide

From each subscribee's =SkgNode=:
- =contains: Option<Vec<ID>>= - the content to categorize as hidden/unintegrated

** 4. New module: =to_org/expand/subscriptions.rs=
Similar to =aliases.rs=, with entry point:
#+begin_src rust
pub async fn build_and_integrate_subscriptions (
  tree      : &mut PairTree,
  node_id   : NodeId,
  config    : &SkgConfig,
  driver    : &TypeDBDriver,
) -> Result < (), Box<dyn Error> >
#+end_src

*** Algorithm
1. Get N's PID
2. If already has SubscriptionCol child, return early
3. Fetch N's SkgNode to get =subscribes_to= and =hides_from_its_subscriptions=
4. If =subscribes_to= is empty/None, return early (no SubscriptionCol needed)
5. Create SubscriptionCol node (no SkgNode, empty title, relToParent = SubscriptionCol)
6. For each subscribee ID S in =subscribes_to=:
   - Fetch S's SkgNode to get its =contains= list
   - Create Subscribee node (with SkgNode, S's title, relToParent = Subscribee, id = S's pid, indefinitive = true)
   - Create Hidden node (no SkgNode, title = "hidden", relToParent = Hidden)
   - Create Unintegrated node (no SkgNode, title = "unintegrated", relToParent = Unintegrated)
   - For each content C in S's contains:
     - If C is in =hides_from_its_subscriptions=: append to Hidden's children
     - Else: append to Unintegrated's children
     - Each C node should be: indefinitive = true, relToParent = Content, has its SkgNode

** 5. New module: =to_org/complete/subscriptioncol.rs=
Similar to =aliascol.rs=, for reconciling existing SubscriptionCol with disk state.

** 6. Update =to_org/complete/contents.rs=
In =completeAndRestoreNode_collectingDefinitiveRequests=:
- Add case for =RelToParent::SubscriptionCol= similar to =AliasCol=
- Add handling of =ViewRequest::Subscriptions= in the view request processing section

* Key Differences from AliasCol
| Aspect                | AliasCol                    | SubscriptionCol                                                              |
|-----------------------+-----------------------------+------------------------------------------------------------------------------|
| Depth                 | 2 generations (Col → Alias) | 4 generations (Col → Subscribee → Hidden/Unintegrated → Content)             |
| Children have IDs     | No (identified by title)    | Yes (Subscribee and Content nodes have IDs)                                  |
| Children have SkgNode | No                          | Yes (Subscribee and Content)                                                 |
| Children indefinitive | N/A (no body concept)       | Yes, all must be indefinitive                                                |
| Data source           | N's =aliases=               | N's =subscribes_to=, N's =hides_from_its_subscriptions=, each S's =contains= |
| Completeness logic    | Reconcile titles            | Reconcile IDs at multiple levels                                             |

* Questions to Resolve

1. *Should Subscribee nodes also render their title?* Currently shown as indefinitive, but we'd need to fetch their SkgNode anyway to get their =contains=.

2. *What about nested subscriptions?* If a subscribee S also subscribes to things, should those be shown? The spec says "no more generations rendered beneath C" so probably not.

3. *Should Hidden and Unintegrated be renderable as definitive later?* The spec mentions "Later a user will be able to request expansion to more generations" - this would need a new ViewRequest type.

4. *What if a subscribee doesn't exist?* Should we skip it, show an error node, or fail?
