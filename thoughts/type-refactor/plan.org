#+title: Incremental Plan for OrgNode Type Refactor

* Goal
  Split OrgNode into TrueNode | Scaffold to make invalid states unrepresentable.
  See spec-questions.org for the target type hierarchy.

* Guiding principles
** Tests pass after every step
** Introduce new types alongside old, then migrate, then remove old
** Small commits with clear descriptions
** When in doubt, add a conversion function rather than change everything at once
** Before deviating from the plan, stop and report.
   This plan looks great. But when the rubber hits the road it's very likely you'll encounter something unanticipated. Before making any important unforeseen decisions, report the fork in the road to me.
** Short atomic functions, with names long enough to sufficiently describe their responsibilities.
** Minimizate the diff against branch 'main'
   Write the new code in a way that minimizes the diff between this "type-refactor" branch and "main". (Don't change any branch but "type-refactor".) That means, for instance, that eventually there should only be one orgnode type, like there used to be, and it should be defined in a file of the same name.
* DONE Phases 1-8
  These plans have been moved to the neighboring file 'done.org'.
* DONE Phase 9: Eliminate Interp from runtime code
  Goal: Replace all uses of Interp:: with direct OrgNode type checks.
  Completed: Reduced Interp usage from 13 files to 6 files.
  Remaining: to_naive_instructions.rs (Phase 10), parsing (Phase 11), old types (Phase 12).

** 9.1 Replace matches_interp() calls with direct type checks
   Currently: node.matches_interp(&Interp::AliasCol)
   Change to: node.is_scaffold(&ScaffoldKind::AliasCol)

   For TrueNode effects:
   Currently: node.matches_interp(&Interp::Content)
   Change to: node.has_effect(EffectOnParent::Content)

   Files to update:
   - server/to_org/complete/contents.rs (4 sites)
   - server/to_org/complete/sharing.rs (3 sites)
   - server/to_org/complete/aliascol.rs (2 sites)
   - server/to_org/expand/definitive.rs (3 sites)
   - server/types/tree/orgnode_skgnode.rs (3 sites)

** 9.2 Change insert_sourceless_node() to take ScaffoldKind
   Currently: insert_sourceless_node(tree, parent_id, Interp::AliasCol, ...)
   Change to: insert_sourceless_node(tree, parent_id, ScaffoldKind::AliasCol, ...)

   Files calling it:
   - server/to_org/expand/aliases.rs
   - server/to_org/complete/sharing.rs
   - server/to_org/complete/aliascol.rs

** 9.3 Change append_indefinitive_node() to take EffectOnParent
   Currently: append_indefinitive_node(..., Interp::Subscribee, ...)
   Change to: append_indefinitive_node(..., EffectOnParent::Subscribee, ...)

   Files calling it:
   - server/to_org/complete/sharing.rs
   - server/to_org/expand/backpath.rs

** 9.4 Change unique_child_with_interp() to unique_scaffold_child()
   DECISION: Use single function taking ScaffoldKind.
   Looking at usage, it's only ever called with scaffold kinds (AliasCol,
   SubscribeeCol, HiddenInSubscribeeCol), never with Content/Subscribee.

   Rename: unique_child_with_interp() -> unique_scaffold_child()
   Change param: Interp -> ScaffoldKind

   Files calling it:
   - server/to_org/expand/aliases.rs
   - server/to_org/complete/sharing.rs

* DONE Phase 10: Eliminate Interp from save instructions
  Goal: Refactor to_naive_instructions.rs to not use Interp.
  Completed: Replaced Interp checks with OrgNodeKind matching and has_effect()/is_scaffold() calls.
  Interp usage reduced from 6 files to 5 files.

** 10.1 Refactor naive_saveinstructions_from_tree()
   Current pattern:
     match interp {
       Interp::ForestRoot => ...,
       Interp::AliasCol | Interp::Alias | ... => skip,
       _ => process
     }

   New pattern:
     match &node.kind {
       OrgNodeKind::Scaff(s) => match s.kind {
         ScaffoldKind::ForestRoot => ...,
         _ => skip // all other scaffolds
       },
       OrgNodeKind::True(_) => process
     }

** 10.2 Refactor collect_subscribees()
   Change to use is_scaffold() checks.

** 10.3 Refactor collect_contents_that_are_not_to_delete()
   Change Interp::Content check to has_effect(EffectOnParent::Content).

* Phase 11: Eliminate Interp from parsing
  Goal: Change parser to produce OrgNode directly, so Interp becomes dead code.

  The from_parsed() function already does this conversion, so we're
  essentially inlining that logic into the parser. This lets us delete
  Interp entirely in Phase 12.

** 11.1 Change parse_metadata_sexp.rs
   Instead of returning OrgnodeMetadata, return a simpler intermediate
   struct that from_parsed() (or its logic inlined) can use to build OrgNode.
   Or parse directly to OrgNode components.

** 11.2 Update uninterpreted.rs
   Call the new parser and construct OrgNode directly,
   removing the from_parsed() call.

* Phase 12: Remove old types
  Goal: Delete unused types after migration complete.

** 12.1 Remove from orgnode.rs (after Interp no longer used externally)
   - Interp enum
   - OrgnodeMetadata struct (if not needed for parsing)
   - OrgnodeCode struct
   - orgnodemd_to_string() function
   - default_metadata() function

   KEEP:
   - OrgnodeViewData (used by TrueNode)
   - OrgnodeRelationships (used by OrgnodeViewData)
   - EditRequest, ViewRequest (used by both old and new)

** 12.2 Remove bridge functions from orgnode_new.rs
   - from_parsed() (if parser changed)
   - matches_interp() (after 9.1)
   - interp() (bridge function)
   - effect_on_parent_from_interp() (after 9.3)
   - orgnode_scaffold_from_interp() (after 9.2)

* Phase 13: File reorganization (minimize diff with main)
  Goal: Single OrgNode type in orgnode.rs, matching main branch structure.

** 13.1 Move OrgNode types from orgnode_new.rs to orgnode.rs
   - OrgNode, OrgNodeKind, TrueNode, Scaffold, ScaffoldKind, EffectOnParent
   - Helper functions like forest_root_orgnode()

** 13.2 Delete orgnode_new.rs

** 13.3 Update all imports
   Change: use crate::types::orgnode_new::OrgNode
   To:     use crate::types::orgnode::OrgNode

** 13.4 Final cleanup
   - Ensure orgnode.rs exports match main branch structure
   - Remove any remaining type aliases for backwards compatibility

* maybe later
** Make TrueNode.id required (separate refactor as discussed)
** Make TrueNode.source required (separate refactor)
** Consider splitting TrueNode further by effect_on_parent
* Testing strategy
  - Run `cargo nextest run` after each numbered step
  - Run `bash/integration-tests.sh` after each phase
  - If tests fail, fix before proceeding
  - Commit after each passing step for easy bisection
* PROBABLY DONE : tricky|dangerous parts

** Interp is used in match statements everywhere
   The current code has many `match interp { ... }` blocks.
   After the refactor, these become `match kind { True(t) => ..., Scaff(s) => ... }`.

   DANGER: It's easy to miss a match arm or handle a case incorrectly.

   MITIGATION: The compiler will catch missing arms if we remove Interp variants.
   But during the transition, both old and new types exist, so we lose this safety.

   SUGGESTION: Add #[deny(unreachable_patterns)] where possible.
   Consider adding a "bridge" function that maps old Interp to new kind,
   so there's one authoritative place for the mapping.

** OrgnodeMetadata is deeply nested
   Current: OrgNode.metadata.code.interp
   New: OrgNode.kind (TrueNode | Scaffold)

   DANGER: Many field accesses like `node.metadata.code.interp` need updating.
   Easy to miss some, especially in less-tested code paths.

   MITIGATION: Use grep/IDE to find all `.metadata.code.interp` accesses.
   The compiler will catch type errors, but semantic errors are possible.

*** DONE a
    Bear in mind that there might be lots of whitespace in that string, and it might even be spread across multiple lines. (Sorry, that's how I find the code easy to read.)

** focused/folded move from OrgnodeViewData to OrgNode
   Current: OrgNode.metadata.view_data.focused
   New: OrgNode.focused

   DANGER: These fields are accessed in many places.
   Some code might assume all OrgNodes have view_data (they do now).
   After refactor, Scaffolds don't have view_data, but DO have focused/folded.

   MITIGATION: Search for all `.view_data.focused` and `.view_data.folded`.
   Update to use the top-level fields.

** Scaffold validation becomes type-enforced but happens later
   Current: Validation checks "AliasCol should not have body".
   New: Scaffold type has no body field, so this is impossible.

   DANGER: The error must now occur during parsing, not validation.
   If parsing creates a Scaffold when there's body text, that text is silently lost.

   MITIGATION: Parser must error when scaffold-interp headline has body.
   Add explicit test: "parsing AliasCol with body produces error".

** PairTree (Tree<NodePair>) contains OrgNode
   NodePair has: orgnode: OrgNode, skgnode: Option<SkgNode>

   DANGER: Updating OrgNode affects NodePair, which affects PairTree.
   PairTree is used throughout the rendering pipeline.

   MITIGATION: NodePair is just a container; updating OrgNode type
   should propagate automatically. But watch for places that construct
   NodePair manually.

** title_from_scaffold_kind() must match current behavior
   The strings are scattered across the codebase.

   DANGER: If titleFromInterp returns different strings than current code,
   round-trip tests will fail, or worse, behavior changes silently.

   MITIGATION: I found the strings (see spec-questions.org).
   Add a test that the function returns exactly these strings.
   Compare against the actual code locations:
   - AliasCol: "" (but should become "It has these aliases.")
   - SubscribeeCol: "it subscribes to these"
   - HiddenOutsideOfSubscribeeCol: "hidden from all subscriptions"
   - HiddenInSubscribeeCol: "hidden from this subscription"
   - ForestRoot: ""
*** DONE a
    Now that I see what the others are, let's change the AliasCol title to match that style: just use "its aliases'.
** Conversion functions must be truly lossless
   from_old_orgnode() and to_old_orgnode() are used during transition.

   DANGER: If conversion loses information, bugs appear only when
   old and new code interact (hard to reproduce).

   MITIGATION: Exhaustive round-trip tests.
   Property test: for any valid OrgNode o, to_old(from_old(o)) == o.
   Property test: for any valid NewOrgNode n, from_old(to_old(n)) == n.

** Test coverage may not catch all edge cases
   Some code paths are only exercised by integration tests or manual testing.

   DANGER: A type change might break a rarely-used feature.

   MITIGATION: Run full integration test suite after each phase.
   Consider adding more unit tests for under-tested code before refactoring.

** sexp serialization format must not change
   The metadata sexp (skg ...) is parsed by both Rust and Emacs.

   DANGER: If the new types serialize differently, Emacs breaks.

   MITIGATION: orgnodemd_to_string() must produce identical output.
   Add test: "new type serializes to same sexp as old type".
   The sexp format is the contract; internal types can change freely.
