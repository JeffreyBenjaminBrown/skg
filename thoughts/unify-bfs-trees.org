* Unifying Tree Types Between initial_view_bfs.rs and definitive_branch.rs

** The Problem

~initial_view_bfs.rs~ uses ~Tree<(SkgNode, OrgNode)>~ pairs, while ~definitive_branch.rs~
uses plain ~Tree<OrgNode>~. This causes:

1. Code duplication - similar BFS logic implemented twice
2. The comment in ~indefinitize_content_subtree~ notes it would be "more natural to call
   clobberIndefinitiveOrgnode" if we had (SkgNode, OrgNode) trees
3. Different visited map types: ~HashSet<ID>~ vs ~VisitedMap~ (HashMap<ID, (usize, NodeId)>)

** The Challenge

~definitive_branch.rs~ operates on an *existing* ~Vec<Tree<OrgNode>>~ forest that comes
from ~completeOrgnodeForest_collectingDefinitiveRequests~. We can't just change the forest
type without changing the completion logic too.

** Options

*** Option A: Convert forest to (SkgNode, OrgNode) pairs before definitive expansion

When ~execute_definitive_view_requests~ is called:
1. Convert ~Vec<Tree<OrgNode>>~ to ~Vec<Tree<(SkgNode, OrgNode)>>~
2. Do all the BFS expansion work
3. Convert back to ~Vec<Tree<OrgNode>>~

Pros:
- Can share most BFS code directly
- Cleaner abstraction

Cons:
- Two conversions (wasteful)
- Need to fetch SkgNodes for *all* existing nodes, even those we won't touch

*** Option B: Make complete_contents.rs use (SkgNode, OrgNode) pairs from the start

Change ~completeOrgnodeForest_collectingDefinitiveRequests~ to work with
~Vec<Tree<(SkgNode, OrgNode)>>~ throughout. Convert to ~Vec<Tree<OrgNode>>~ only
at the very end.

Pros:
- No conversion in definitive_branch
- More consistent data model
- SkgNode data is already being fetched - just need to keep it

Cons:
- Bigger refactor of complete_contents.rs
- Changes the interface for other callers of completion functions

*** Option C: Generic BFS helper that works with both tree types

Create a trait that abstracts over accessing the OrgNode and SkgNode data, then
write generic BFS code.

Pros:
- Minimal changes to existing code
- Can share logic without changing data structures

Cons:
- More complex (trait machinery)
- Still some duplication at the call sites

*** Option D: Extract shared logic into functions that take closures for tree access

Similar to Option C but simpler - just pass accessor functions.

** Analysis

Looking at the actual code:

1. ~initial_view_bfs.rs~ creates a fresh forest via ~stub_forest_from_root_ids~
2. ~definitive_branch.rs~ receives an existing forest that was built by tree completion

The key insight: ~completeOrgnodeForest_collectingDefinitiveRequests~ already fetches
SkgNodes (in ~clobberIndefinitiveOrgnode~, ~completeDefinitiveOrgnode~, etc.) but
immediately discards them. If we kept them, we'd have (SkgNode, OrgNode) pairs naturally.

** Chosen Approach: Revised - Keep OrgNode trees, share BFS logic via conversion

After reviewing the code more carefully:

- ~buffer_to_save_instructions~ produces ~Tree<OrgNode>~ (parsing user text, no SkgNode)
- ~complete_contents.rs~ modifies that forest in place
- Changing the entire pipeline to ~(SkgNode, OrgNode)~ would be invasive

Revised approach:
1. Keep ~complete_contents.rs~ using ~Tree<OrgNode>~
2. In ~definitive_branch.rs~, when expanding a subtree:
   - Build a temporary ~Tree<(SkgNode, OrgNode)>~ for the new content
   - Use shared BFS logic (same as initial_view_bfs)
   - Convert back and graft onto the main tree
3. Extract shared BFS module that both can use

** Implementation Plan

*** Phase 1: Create shared BFS module

Create ~rust/to_org/bfs_shared.rs~ with:
- Type alias for paired tree: ~type PairedTree<T> = Tree<(SkgNode, T)>~
- ~add_child_checking_cycles_and_repeats~ - unified logic
- ~truncate_generation_after_node~ - unified truncation
- Helper to access OrgNode from either tree type via trait or closure

*** Phase 2: Refactor initial_view_bfs.rs to use shared module

- Extract BFS logic into shared module
- Keep ~initial_view_bfs.rs~ as thin wrapper

*** Phase 3: Refactor definitive_branch.rs to use shared module

Key insight: ~extendDefinitiveSubtreeFromLeaf~ already fetches (SkgNode, OrgNode)
pairs but discards the SkgNode. Instead:
- Build children as ~(SkgNode, OrgNode)~ pairs
- Use shared BFS logic
- When appending to the parent OrgNode tree, just take the OrgNode

*** Phase 4: Unify visited map type

Change ~initial_view_bfs.rs~ to use ~VisitedMap~ instead of ~HashSet<ID>~.
This also positions it for future "only one definitive per ID" enforcement.

** Implementation Progress (as of last session)

*** DONE: Shared BFS module
Created ~rust/to_org/bfs_shared.rs~ with shared helpers:
- ~is_cycle_in_mskg_org_tree~ / ~is_cycle_in_orgnode_tree~
- ~mark_indefinitive_paired~ / ~mark_indefinitive_in_org_tree~
- ~set_cycle_flag_paired~ / ~set_cycle_flag_in_orgnode_tree~
- ~get_pid_from_paired~ / ~get_pid_in_orgnode_tree~
- ~is_indefinitive_paired~ / ~is_indefinitive_in_org_tree~
- ~collect_content_children_paired~
- ~mark_cycles_and_repeats_hashset~ (for initial_view_bfs)
- ~mark_cycles_and_repeats_updating_visitedmap_in_skg_org_tree~ (for definitive_branch)
- ~mark_cycles_and_repeats_updating_visitedmap_in_org_tree~

*** DONE: Refactored initial_view_bfs.rs
- Uses shared ~mark_cycles_and_repeats_hashset~
- Uses shared ~collect_content_children_paired~
- Uses shared ~mark_indefinitive_paired~
- ~truncate.rs~ also uses shared helpers

*** DONE: Added tree conversion utility
Created ~pair_forest_with_skgnodes~ in ~rust/media/tree.rs~:
- Converts ~Vec<Tree<OrgNode>>~ to ~Vec<Tree<(SkgNode, OrgNode)>>~
- Uses a closure to look up SkgNodes by ID from a cache
- Nodes without cached SkgNode get ~empty_skgnode()~

*** DONE: Add SkgNode cache to completion phase
Modified ~completeOrgnodeForest_collectingDefinitiveRequests~ to:
- Return ~SkgNodeCache~ (HashMap<ID, SkgNode>) alongside visited and definitive_requests
- Populate cache in ~clobberIndefinitiveOrgnode~, ~completeDefinitiveOrgnode~, and ~extend_content~
- Cache eliminates redundant disk reads during definitive expansion

*** DONE: Update save_buffer.rs flow
Updated ~update_from_and_rerender_buffer~ to:
1. Call ~pair_forest_with_skgnodes~ with the cache
2. Call ~execute_definitive_view_requests~ on paired forest
3. Call ~map_snd_over_forest~ to extract OrgNodes

*** DONE: Rewrite definitive_branch.rs for paired trees
Changed all functions to work with ~Tree<(SkgNode, OrgNode)>~:
- ~execute_definitive_view_requests~ now takes paired forest
- ~indefinitize_content_subtree~ can now restore canonical title from SkgNode
- ~extendDefinitiveSubtreeFromLeaf~ reads content children from tree via ~collect_content_children_paired~
- ~add_child_to_definitive_branch~ stores new SkgNodes in the paired tree
- All truncation functions updated for paired trees

*** DONE: Clean up unused imports
Removed unused imports (~mark_indefinitive_paired~, ~content_ids_from_skgnode~)
from definitive_branch.rs. Left ~node_generation~ with ~#[allow(dead_code)]~ as
it may be useful for debugging.

** Implementation Complete (December 2024)

All phases completed successfully:
- Both ~initial_view_bfs.rs~ and ~definitive_branch.rs~ now use ~Tree<(SkgNode, OrgNode)>~
- Shared BFS module provides common functionality
- SkgNode cache eliminates redundant disk reads
- All unit tests and integration tests pass

** Key Functions to Unify

| initial_view_bfs.rs              | definitive_branch.rs                   | Action                  |
|----------------------------------+----------------------------------------+-------------------------|
| mark_cycles_and_repeats          | (in add_child_to_definitive_branch)    | Extract common logic    |
| add_children_and_collect_ids     | (main loop in extendDefinitive...)     | Parameterize            |
| add_children_with_truncation     | add_last_generation_and_edit_previous  | Unify                   |
| truncate::truncate_after_node... | truncate_after_node_in_generation      | Already similar         |
| truncate::truncate_node          | truncate_and_unvisit_node              | Unify (one removes from |
|                                  |                                        | visited, one doesn't)   |

** Risks

1. Large refactor touching multiple files
2. Need to update all callers of completion functions
3. Tests may need updating

** Mitigation

- Make changes incrementally, testing after each phase
- Phase 1 is the biggest - if it works, rest follows naturally
