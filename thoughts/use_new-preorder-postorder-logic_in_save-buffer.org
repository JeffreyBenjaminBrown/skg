* Context

The =update_from_and_rerender_buffer= function in
=server/serve/handlers/save_buffer.rs= (line 138) currently uses an
ad-hoc pipeline of legacy functions to update the view after saving:

1. =complete_or_restore_each_node_in_branch= (preorder completion)
2. =collectViewRequestsFromForest= + =execute_view_requests= (view request expansion)
3. =set_graphnodestats_in_forest= (TypeDB relationship stats)
4. =set_viewnodestats_in_forest= (containment + cycle stats)
5. =apply_diff_to_forest= (git diff markers)

Steps 1-2 are now subsumed by =complete_viewtree=, which does both
preorder completion and postorder view-request execution in a single
two-pass DFS. Steps 3-4 already use the new entry points. Step 5
is still needed (see Problems).

* File to modify

=server/serve/handlers/save_buffer.rs=

* Change

Replace the block at roughly lines 192-221 (the inner ={ // mutate it
before re-rendering it= block) with:

#+begin_src rust
    { // mutate it before re-rendering it
      let mut visited : DefinitiveMap = DefinitiveMap::new();
      complete_viewtree (
        &mut forest_mut,
        &mut skgnode_map,
        &mut visited,
        &source_diffs,
        config,
        typedb_driver,
        &mut errors,
        &deleted_id_src_map ). await ?;
      let ( container_to_contents, content_to_containers ) =
        set_graphnodestats_in_forest (
          &mut forest_mut,
          config,
          typedb_driver ). await ?;
      set_viewnodestats_in_forest (
        &mut forest_mut,
        &container_to_contents,
        &content_to_containers );
      if let Some ( ref diffs ) = source_diffs {
        apply_diff_to_forest (
          &mut forest_mut, diffs, config ) ?; }}
#+end_src

** Import changes

Add:
: use crate::update_buffer::complete::complete_viewtree;

Remove (now unused in this file):
: use crate::to_org::complete::contents::complete_or_restore_each_node_in_branch;
: use crate::to_org::expand::collect_view_requests::collectViewRequestsFromForest;
: use crate::to_org::expand::definitive::execute_view_requests;

Keep (still used):
: use crate::update_buffer::graphnodestats::set_graphnodestats_in_forest;
: use crate::update_buffer::viewnodestats::set_viewnodestats_in_forest;

Also keep =DefinitiveMap= (still constructed here and passed to
=complete_viewtree=).

Remove =ViewRequest= from the ={ViewNode, ViewNodeKind, Scaffold,
ViewRequest}= import if it becomes unused.

** Signature alignment

=complete_viewtree= takes =source_diffs : &Option<HashMap<...>>=,
which matches the local =source_diffs : Option<...>= via =&source_diffs=.

=complete_viewtree= takes =deleted_id_src_map : &HashMap<ID, SourceName>=,
which matches the local =deleted_id_src_map : HashMap<ID, SourceName>=
via =&deleted_id_src_map=.

No type mismatches expected.

* Verification

=cargo check=, then =cargo nextest run=.

* Problems

** apply_diff_to_forest is still needed

=complete_truenode_preorder= handles content-level diffs (phantom
children for removed content, diff-aware goal lists) and prepends
TextChanged/IDCol scaffolds. But =apply_diff_to_forest= does
additional things that =complete_viewtree= does not:

- Sets file-level =t.diff= on TrueNodes (=New=, =Removed=, =NotInGit=).
- Marks children as =NewHere= (existed in HEAD but not as content here).
- Populates the IDCol scaffold with ID children (=complete_truenode_preorder=
  only prepends an empty IDCol; the postorder =completeIDCol= populates it,
  but =apply_diff_to_forest= also populates it independently).

I grepped: nothing in =server/update_buffer/= sets =NewHere=, =NotInGit=,
or file-level =NodeDiffStatus::New= / =NodeDiffStatus::Removed= on
existing nodes. So the call must stay.

However, this means two things now both create TextChanged scaffolds
and IDCol scaffolds: =complete_truenode_preorder= (via
=maybe_prepend_diff_view_scaffolds=) and =apply_diff_to_forest= (via
=process_truenode_diff=). This should be harmless if both are
idempotent (checking for existing scaffolds before prepending), but
it's wasteful. In =complete_truenode_preorder=, =maybe_prepend_diff_view_scaffolds=
checks =unique_scaffold_child= before inserting, so duplicates won't
be created. In =apply_diff_to_forest=, =process_truenode_diff=
unconditionally prepends TextChanged and IDCol — it does NOT check
for existing scaffolds. This means if =complete_truenode_preorder=
already added a TextChanged scaffold, =apply_diff_to_forest= will add
a duplicate.

Possible fix: have =apply_diff_to_forest= check for existing
scaffolds before prepending, or have =complete_truenode_preorder= skip
=maybe_prepend_diff_view_scaffolds= when =source_diffs= is present
(since =apply_diff_to_forest= will handle it). But both are
out-of-scope for this plan — I'm flagging it so it can be addressed
next.

** The old functions may still have callers elsewhere

=complete_or_restore_each_node_in_branch= might be called from
other places. If so, removing its import from =save_buffer.rs= is
fine but the function itself should not be deleted yet.

** =complete_viewtree= does more than the old pipeline

The old pipeline calls =complete_or_restore_each_node_in_branch=,
which is a simpler preorder pass: it adds missing content children,
handles AliasCol, and adds a SubscribeeCol. It does NOT call the
child-first handlers (=completeIDCol=, =complete_hiddeninsubscribee_col=,
etc.). =complete_viewtree= does both preorder AND postorder, so it
does strictly more work. This is the intended behavior, but it means
this change is not a pure refactor — it changes the set of operations
performed during save-and-rerender.
